<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">



<title>sanic安装 | </title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">ww</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">帖子</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">简历</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">ww</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">帖子</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">简历</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">sanic安装</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">ww</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">九月 9, 2019&nbsp;&nbsp;23:45:19</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h6 id="SANIC是一个python-3-6-web服务器和web框架，它的编写速度很快。它允许使用python-3-5中添加的async-await语法，这使得您的代码不阻塞，速度更快"><a href="#SANIC是一个python-3-6-web服务器和web框架，它的编写速度很快。它允许使用python-3-5中添加的async-await语法，这使得您的代码不阻塞，速度更快" class="headerlink" title="SANIC是一个python 3.6+web服务器和web框架，它的编写速度很快。它允许使用python 3.5中添加的async/await语法，这使得您的代码不阻塞，速度更快"></a>SANIC是一个python 3.6+web服务器和web框架，它的编写速度很快。它允许使用python 3.5中添加的async/await语法，这使得您的代码不阻塞，速度更快</h6><h6 id="该项目的目标是提供一种简单的方法来启动和运行一个高性能的HTTP服务器，该服务器易于构建、扩展和最终扩展。"><a href="#该项目的目标是提供一种简单的方法来启动和运行一个高性能的HTTP服务器，该服务器易于构建、扩展和最终扩展。" class="headerlink" title="该项目的目标是提供一种简单的方法来启动和运行一个高性能的HTTP服务器，该服务器易于构建、扩展和最终扩展。"></a>该项目的目标是提供一种简单的方法来启动和运行一个高性能的HTTP服务器，该服务器易于构建、扩展和最终扩展。</h6><h6 id="只能在linux上运行Sanic"><a href="#只能在linux上运行Sanic" class="headerlink" title="只能在linux上运行Sanic"></a>只能在linux上运行Sanic</h6><p>中文文档：<a href="https://www.osgeo.cn/sanic/sanic/examples.html" target="_blank" rel="noopener">https://www.osgeo.cn/sanic/sanic/examples.html</a></p>
<p>简单demo</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sanic <span class="keyword">import</span> Sanic</span><br><span class="line"><span class="keyword">from</span> sanic.response <span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">app = Sanic()</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/")</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> json(&#123;<span class="string">"hello"</span>: <span class="string">"world"</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run(host=<span class="string">"0.0.0.0"</span>, port=<span class="number">8000</span>)</span><br></pre></td></tr></table></figure>

<h2 id="1-安装-SANIC"><a href="#1-安装-SANIC" class="headerlink" title="1. 安装 SANIC"></a>1. 安装 SANIC</h2><blockquote>
<p>如果您运行的是全新安装的Fedora 28或更高版本，请确保安装了Redhat RPM配置包，以防您希望使用SANIC和UJSON依赖项。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install sanic</span><br></pre></td></tr></table></figure>

<p>要在不使用uvloop或ujson的情况下使用bash安装sanic，您可以使用诸如’y’、’yes’、’t’、’true’、’on’、’1’之类的任何Truthy字符串提供这些环境变量中的一个或两个，并将sanic_no_x（x=uvloop/ujson）设置为true将停止该功能的安装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SANIC_NO_UVLOOP=true SANIC_NO_UJSON=true pip3 install sanic</span><br></pre></td></tr></table></figure>

<p>您也可以从Conda Forge安装Sanic</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels conda-forge</span><br><span class="line">conda install sanic</span><br></pre></td></tr></table></figure>

<h2 id="2-创建名为main-py的文件"><a href="#2-创建名为main-py的文件" class="headerlink" title="2. 创建名为main.py的文件"></a>2. 创建名为main.py的文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from sanic import Sanic</span><br><span class="line">from sanic.response import json</span><br><span class="line"></span><br><span class="line">app = Sanic()</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&quot;)</span><br><span class="line">async def test(request):</span><br><span class="line">    return json(&#123;&quot;hello&quot;: &quot;world&quot;&#125;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app.run(host=&quot;0.0.0.0&quot;, port=8000)</span><br></pre></td></tr></table></figure>

<h2 id="3-运行服务器"><a href="#3-运行服务器" class="headerlink" title="3. 运行服务器"></a>3. 运行服务器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 main.py</span><br></pre></td></tr></table></figure>

<h2 id="4-检查浏览器"><a href="#4-检查浏览器" class="headerlink" title="4. 检查浏览器"></a>4. 检查浏览器</h2><p>在Web浏览器中打开地址<a href="http://0.0.0.0:8000。你应该看到“你好，世界”的信息！" target="_blank" rel="noopener">http://0.0.0.0:8000。你应该看到“你好，世界”的信息！</a>.</p>
<p>你现在有了一台正常工作的服务器！</p>
<h1 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h1><p>当端点接收到HTTP请求时，路由函数将传递一个请求对象。</p>
<p>以下变量可作为请求对象的属性进行访问：</p>
<ul>
<li><p>JSON（任意）-JSON主体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from sanic.response import json</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/json&quot;)</span><br><span class="line">def post_json(request):</span><br><span class="line">    return json(&#123; &quot;received&quot;: True, &quot;message&quot;: request.json &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>args</code> (dict) - Query string variables. A query string is the section of a URL that resembles <code>?key1=value1&amp;key2=value2</code>. If that URL were to be parsed, the <code>args</code> dictionary would look like <code>{&#39;key1&#39;: [&#39;value1&#39;], &#39;key2&#39;: [&#39;value2&#39;]}</code>. The request’s <code>query_string</code> variable holds the unparsed string value. Property is providing the default parsing strategy. If you would like to change it look to the section below (<code>Changing the default parsing rules of the queryset</code>).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from sanic.response import json</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/query_string&quot;)</span><br><span class="line">def query_string(request):</span><br><span class="line">    return json(&#123; &quot;parsed&quot;: True, &quot;args&quot;: request.args, &quot;url&quot;: request.url, &quot;query_string&quot;: request.query_string &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询参数（list）-在许多情况下，您需要以一种不那么紧凑的形式访问URL参数。query参数是（key，value）元组的列表。属性提供默认的分析策略。如果要更改它，请查看下面的部分（更改查询集的默认解析规则）。对于相同的上一个URL查询集？key1=value1&amp;key2=value2，查询参数列表如下 [（’key1’、’value1’）、（’key2’、’value2’）] . 如果多个参数具有相同的键，比如？key1=value1&amp;key2=value2&amp;key1=value3查询参数列表如下 [（’key1’、’value1’）、（’key2’、’value2’）、（’key1’、’value3’）] .</p>
<p>queryset的request.args和request.query参数之间的差异？key1=value1&amp;key2=value2&amp;key1=value3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from sanic import Sanic</span><br><span class="line">from sanic.response import json</span><br><span class="line"></span><br><span class="line">app = Sanic(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&quot;/test_request_args&quot;)</span><br><span class="line">async def test_request_args(request):</span><br><span class="line">    return json(&#123;</span><br><span class="line">        &quot;parsed&quot;: True,</span><br><span class="line">        &quot;url&quot;: request.url,</span><br><span class="line">        &quot;query_string&quot;: request.query_string,</span><br><span class="line">        &quot;args&quot;: request.args,</span><br><span class="line">        &quot;raw_args&quot;: request.raw_args,</span><br><span class="line">        &quot;query_args&quot;: request.query_args,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(host=&quot;0.0.0.0&quot;, port=8000)</span><br></pre></td></tr></table></figure>

<p>产量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;parsed&quot;:true,</span><br><span class="line">  &quot;url&quot;:&quot;http:\/\/0.0.0.0:8000\/test_request_args?key1=value1&amp;key2=value2&amp;key1=value3&quot;,</span><br><span class="line">  &quot;query_string&quot;:&quot;key1=value1&amp;key2=value2&amp;key1=value3&quot;,</span><br><span class="line">  &quot;args&quot;:&#123;&quot;key1&quot;:[&quot;value1&quot;,&quot;value3&quot;],&quot;key2&quot;:[&quot;value2&quot;]&#125;,</span><br><span class="line">  &quot;raw_args&quot;:&#123;&quot;key1&quot;:&quot;value1&quot;,&quot;key2&quot;:&quot;value2&quot;&#125;,</span><br><span class="line">  &quot;query_args&quot;:[[&quot;key1&quot;,&quot;value1&quot;],[&quot;key2&quot;,&quot;value2&quot;],[&quot;key1&quot;,&quot;value3&quot;]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原始参数只包含key1的第一个条目。将在将来的版本中被弃用。</p>
</li>
<li><p>文件（文件对象字典）-具有名称、正文和类型的文件列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from sanic.response import json</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/files&quot;)</span><br><span class="line">def post_json(request):</span><br><span class="line">    test_file = request.files.get(&apos;test&apos;)</span><br><span class="line"></span><br><span class="line">    file_parameters = &#123;</span><br><span class="line">        &apos;body&apos;: test_file.body,</span><br><span class="line">        &apos;name&apos;: test_file.name,</span><br><span class="line">        &apos;type&apos;: test_file.type,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return json(&#123; &quot;received&quot;: True, &quot;file_names&quot;: request.files.keys(), &quot;test_file_parameters&quot;: file_parameters &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>表单（dict）-发布的表单变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from sanic.response import json</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/form&quot;)</span><br><span class="line">def post_json(request):</span><br><span class="line">    return json(&#123; &quot;received&quot;: True, &quot;form_data&quot;: request.form, &quot;test&quot;: request.form.get(&apos;test&apos;) &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>正文（字节）-已发布的原始正文。此属性允许检索请求的原始数据，而不考虑内容类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from sanic.response import text</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/users&quot;, methods=[&quot;POST&quot;,])</span><br><span class="line">def create_user(request):</span><br><span class="line">    return text(&quot;You are trying to create a user with the following POST: %s&quot; % request.body)</span><br></pre></td></tr></table></figure>
</li>
<li><p>头（dict）-包含请求头的不区分大小写的字典。</p>
</li>
<li><p>方法（str）-请求的HTTP方法（即get、post）。</p>
</li>
<li><p>IP（str）-请求者的IP地址。</p>
</li>
<li><p>端口（str）-请求者的端口地址。</p>
</li>
<li><p>套接字（元组）-请求者的（IP，端口）。</p>
</li>
<li><p>应用程序-对处理此请求的SANIC应用程序对象的引用。当在没有访问全局应用程序对象的模块中的设计图或其他处理程序内时，这很有用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from sanic.response import json</span><br><span class="line">from sanic import Blueprint</span><br><span class="line"></span><br><span class="line">bp = Blueprint(&apos;my_blueprint&apos;)</span><br><span class="line"></span><br><span class="line">@bp.route(&apos;/&apos;)</span><br><span class="line">async def bp_root(request):</span><br><span class="line">    if request.app.config[&apos;DEBUG&apos;]:</span><br><span class="line">        return json(&#123;&apos;status&apos;: &apos;debug&apos;&#125;)</span><br><span class="line">    else:</span><br><span class="line">        return json(&#123;&apos;status&apos;: &apos;production&apos;&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>url：请求的完整url，即：<a href="http://localhost:8000/posts/1/？Fo=棒" target="_blank" rel="noopener">http://localhost:8000/posts/1/？Fo=棒</a></p>
</li>
<li><p>方案：与请求关联的URL方案：“http” <a href="https://www.osgeo.cn/sanic/sanic/request_data.html#id1" target="_blank" rel="noopener">|https|</a> ws wss’或头文件给出的任意值。</p>
</li>
<li><p>主机：与请求关联的主机（在主机头中）：localhost:8080</p>
</li>
<li><p>服务器名称：服务器的主机名，没有端口号。该值按以下顺序显示：config.server_name，x-forwarded-host header，：func:request.host</p>
</li>
<li><p>服务器端口：类似服务器名称。请按以下顺序查看：x-forwarded-port头，：func:request.host，传输层套接字使用的实际端口。</p>
</li>
<li><p>路径：请求的路径：/posts/1/</p>
</li>
<li><p>查询字符串：请求的查询字符串：foo=bar或空字符串’’</p>
</li>
<li><p>uri_template:匹配路由处理程序的模板：/posts/<id>/</id></p>
</li>
<li><p>令牌：授权头的值：basic ywrtaw46ywrtaw4=</p>
</li>
<li><p>url-for：和sanic.sanic.url-for一样，但根据请求自动确定方案和netloc。由于此方法旨在生成正确的模式和netloc，_external是隐含的。</p>
</li>
</ul>
<h2 id="更改查询集的默认分析规则"><a href="#更改查询集的默认分析规则" class="headerlink" title="更改查询集的默认分析规则"></a>更改查询集的默认分析规则</h2><p>在args和query args属性中内部用于分析queryset的默认参数：</p>
<ul>
<li>keep_blank_values（bool）：false-指示百分比编码查询中的空值是否应被视为空字符串的标志。一个真值表示空格应保留为空字符串。默认的false值表示忽略空白值，并将其视为不包括在内。</li>
<li>严格分析（bool）：错误-指示如何处理分析错误的标志。如果为false（默认值），则默认忽略错误。如果为true，则错误会引发ValueError异常。</li>
<li>编码和错误（str）：’utf-8’和’replace’-指定如何将百分比编码序列解码为Unicode字符，bytes.decode（）方法接受这一点。</li>
</ul>
<p>如果要更改该默认参数，可以使用新值调用get-args和get-query-args方法。</p>
<p>对于queryset/？test1=value1&amp;test2=test3=value3:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from sanic.response import json</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/query_string&quot;)</span><br><span class="line">def query_string(request):</span><br><span class="line">    args_with_blank_values = request.get_args(keep_blank_values=True)</span><br><span class="line">    return json(&#123;</span><br><span class="line">        &quot;parsed&quot;: True,</span><br><span class="line">        &quot;url&quot;: request.url,</span><br><span class="line">        &quot;args_with_blank_values&quot;: args_with_blank_values,</span><br><span class="line">        &quot;query_string&quot;: request.query_string</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>输出将是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;parsed&quot;: true,</span><br><span class="line">    &quot;url&quot;: &quot;http:\/\/0.0.0.0:8000\/query_string?test1=value1&amp;test2=&amp;test3=value3&quot;,</span><br><span class="line">    &quot;args_with_blank_values&quot;: &#123;&quot;test1&quot;: [&quot;value1&quot;], &quot;test2&quot;: &quot;&quot;, &quot;test3&quot;: [&quot;value3&quot;]&#125;,</span><br><span class="line">    &quot;query_string&quot;: &quot;test1=value1&amp;test2=&amp;test3=value3&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用get和getlist访问值"><a href="#使用get和getlist访问值" class="headerlink" title="使用get和getlist访问值"></a>使用get和getlist访问值</h2><p>返回字典的请求属性实际上返回一个子类dict，称为requestParameters。使用此对象时的主要区别是get和getlist方法之间的区别。</p>
<ul>
<li>get（key，default=none）正常工作，但是当给定的key的值是一个列表时，只返回第一个项。</li>
<li>getlist（key，默认值为none）正常工作，返回整个列表。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from sanic.request import RequestParameters</span><br><span class="line"></span><br><span class="line">args = RequestParameters()</span><br><span class="line">args[&apos;titles&apos;] = [&apos;Post 1&apos;, &apos;Post 2&apos;]</span><br><span class="line"></span><br><span class="line">args.get(&apos;titles&apos;) # =&gt; &apos;Post 1&apos;</span><br><span class="line"></span><br><span class="line">args.getlist(&apos;titles&apos;) # =&gt; [&apos;Post 1&apos;, &apos;Post 2&apos;]</span><br></pre></td></tr></table></figure>

<h2 id="使用request-endpoint属性访问处理程序名称"><a href="#使用request-endpoint属性访问处理程序名称" class="headerlink" title="使用request.endpoint属性访问处理程序名称"></a>使用request.endpoint属性访问处理程序名称</h2><p>request.endpoint属性保存处理程序的名称。例如，下面的路由将返回“hello”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from sanic.response import text</span><br><span class="line">from sanic import Sanic</span><br><span class="line"></span><br><span class="line">app = Sanic()</span><br><span class="line"></span><br><span class="line">@app.get(&quot;/&quot;)</span><br><span class="line">def hello(request):</span><br><span class="line">    return text(request.endpoint)</span><br></pre></td></tr></table></figure>

<p>或者，对于蓝图，它将包含两者，并用一个句号分隔。例如，下面的路由将返回foo.bar：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from sanic import Sanic</span><br><span class="line">from sanic import Blueprint</span><br><span class="line">from sanic.response import text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Sanic(__name__)</span><br><span class="line">blueprint = Blueprint(&apos;foo&apos;)</span><br><span class="line"></span><br><span class="line">@blueprint.get(&apos;/&apos;)</span><br><span class="line">async def bar(request):</span><br><span class="line">    return text(request.endpoint)</span><br><span class="line"></span><br><span class="line">app.blueprint(blueprint)</span><br><span class="line"></span><br><span class="line">app.run(host=&quot;0.0.0.0&quot;, port=8000, debug=True)</span><br></pre></td></tr></table></figure>

<h1 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h1><p>使用sanic.response模块中的函数创建响应。</p>
<h2 id="纯文本"><a href="#纯文本" class="headerlink" title="纯文本"></a>纯文本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from sanic import response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&apos;/text&apos;)</span><br><span class="line">def handle_request(request):</span><br><span class="line">    return response.text(&apos;Hello world!&apos;)</span><br></pre></td></tr></table></figure>

<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from sanic import response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&apos;/html&apos;)</span><br><span class="line">def handle_request(request):</span><br><span class="line">    return response.html(&apos;&lt;p&gt;Hello world!&lt;/p&gt;&apos;)</span><br></pre></td></tr></table></figure>

<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from sanic import response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&apos;/json&apos;)</span><br><span class="line">def handle_request(request):</span><br><span class="line">    return response.json(&#123;&apos;message&apos;: &apos;Hello world!&apos;&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from sanic import response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&apos;/file&apos;)</span><br><span class="line">async def handle_request(request):</span><br><span class="line">    return await response.file(&apos;/srv/www/whatever.png&apos;)</span><br></pre></td></tr></table></figure>

<h2 id="流动"><a href="#流动" class="headerlink" title="流动"></a>流动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from sanic import response</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/streaming&quot;)</span><br><span class="line">async def index(request):</span><br><span class="line">    async def streaming_fn(response):</span><br><span class="line">        await response.write(&apos;foo&apos;)</span><br><span class="line">        await response.write(&apos;bar&apos;)</span><br><span class="line">    return response.stream(streaming_fn, content_type=&apos;text/plain&apos;)</span><br></pre></td></tr></table></figure>

<p>有关详细信息，请参阅流式处理。</p>
<h2 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h2><p>对于大型文件，上面的文件和流媒体的组合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from sanic import response</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/big_file.png&apos;)</span><br><span class="line">async def handle_request(request):</span><br><span class="line">    return await response.file_stream(&apos;/srv/www/whatever.png&apos;)</span><br></pre></td></tr></table></figure>

<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from sanic import response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&apos;/redirect&apos;)</span><br><span class="line">def handle_request(request):</span><br><span class="line">    return response.redirect(&apos;/json&apos;)</span><br></pre></td></tr></table></figure>

<h2 id="生的"><a href="#生的" class="headerlink" title="生的"></a>生的</h2><p>不编码正文的响应</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from sanic import response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&apos;/raw&apos;)</span><br><span class="line">def handle_request(request):</span><br><span class="line">    return response.raw(b&apos;raw data&apos;)</span><br></pre></td></tr></table></figure>

<h2 id="修改标题或状态"><a href="#修改标题或状态" class="headerlink" title="修改标题或状态"></a>修改标题或状态</h2><p>要修改头或状态代码，请将头或状态参数传递给这些函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from sanic import response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&apos;/json&apos;)</span><br><span class="line">def handle_request(request):</span><br><span class="line">    return response.json(</span><br><span class="line">        &#123;&apos;message&apos;: &apos;Hello world!&apos;&#125;,</span><br><span class="line">        headers=&#123;&apos;X-Served-By&apos;: &apos;sanic&apos;&#125;,</span><br><span class="line">        status=200</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h1 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h1><p>cookie是保存在用户浏览器中的数据片段。SANIC可以读写cookie，cookie存储为键值对。</p>
<p>注意：</p>
<p>客户可以自由更改cookie。因此，您不能只将登录信息等数据按原样存储在cookie中，因为客户机可以自由更改这些数据。为了确保存储在cookie中的数据不会被客户伪造或篡改，请使用类似的 <a href="https://pythonhosted.org/itsdangerous/" target="_blank" rel="noopener">itsdangerous</a> 对数据进行加密签名</p>
<h2 id="读取-cookies"><a href="#读取-cookies" class="headerlink" title="读取 cookies"></a>读取 cookies</h2><p>用户的cookie可以通过 <code>Request</code> 对象的 <code>cookies</code> 字典。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from sanic.response import text</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/cookie&quot;)</span><br><span class="line">async def test(request):</span><br><span class="line">    test_cookie = request.cookies.get(&apos;test&apos;)</span><br><span class="line">    return text(&quot;Test cookie set to: &#123;&#125;&quot;.format(test_cookie))</span><br></pre></td></tr></table></figure>

<h2 id="写-cookies"><a href="#写-cookies" class="headerlink" title="写 cookies"></a>写 cookies</h2><p>返回响应时，可以在 <code>Response</code> 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from sanic.response import text</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/cookie&quot;)</span><br><span class="line">async def test(request):</span><br><span class="line">    response = text(&quot;There&apos;s a cookie up in this response&quot;)</span><br><span class="line">    response.cookies[&apos;test&apos;] = &apos;It worked!&apos;</span><br><span class="line">    response.cookies[&apos;test&apos;][&apos;domain&apos;] = &apos;.gotta-go-fast.com&apos;</span><br><span class="line">    response.cookies[&apos;test&apos;][&apos;httponly&apos;] = True</span><br><span class="line">    return response</span><br></pre></td></tr></table></figure>

<h2 id="删除cookie"><a href="#删除cookie" class="headerlink" title="删除cookie"></a>删除cookie</h2><p>可以从语义上或显式地删除cookie。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from sanic.response import text</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/cookie&quot;)</span><br><span class="line">async def test(request):</span><br><span class="line">    response = text(&quot;Time to eat some cookies muahaha&quot;)</span><br><span class="line"></span><br><span class="line">    # This cookie will be set to expire in 0 seconds</span><br><span class="line">    del response.cookies[&apos;kill_me&apos;]</span><br><span class="line"></span><br><span class="line">    # This cookie will self destruct in 5 seconds</span><br><span class="line">    response.cookies[&apos;short_life&apos;] = &apos;Glad to be here&apos;</span><br><span class="line">    response.cookies[&apos;short_life&apos;][&apos;max-age&apos;] = 5</span><br><span class="line">    del response.cookies[&apos;favorite_color&apos;]</span><br><span class="line"></span><br><span class="line">    # This cookie will remain unchanged</span><br><span class="line">    response.cookies[&apos;favorite_color&apos;] = &apos;blue&apos;</span><br><span class="line">    response.cookies[&apos;favorite_color&apos;] = &apos;pink&apos;</span><br><span class="line">    del response.cookies[&apos;favorite_color&apos;]</span><br><span class="line"></span><br><span class="line">    return response</span><br></pre></td></tr></table></figure>

<p>响应cookie可以设置为字典值，并具有以下可用参数：</p>
<ul>
<li><code>expires</code> （日期时间）：客户端浏览器上的cookie过期时间。</li>
<li><code>path</code> （字符串）：应用此cookie的URL的子集。默认值为</li>
<li><code>comment</code> （字符串）：注释（元数据）。</li>
<li><code>domain</code> （字符串）：指定cookie有效的域。显式指定的域必须始终以点开头。</li>
<li><code>max-age</code> （number）：cookie应生存的秒数。</li>
<li><code>secure</code> （布尔值）：指定是否仅通过HTTPS发送cookie。</li>
<li><code>httponly</code> （布尔值）：指定JavaScript是否无法读取cookie。</li>
</ul>
<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>路由允许用户为不同的URL端点指定处理程序函数。</p>
<p>基本路径如下所示，其中app是sanic类的一个实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from sanic.response import json</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&quot;)</span><br><span class="line">async def test(request):</span><br><span class="line">    return json(&#123; &quot;hello&quot;: &quot;world&quot; &#125;)</span><br></pre></td></tr></table></figure>

<p>当访问url <a href="http://server.url/" target="_blank" rel="noopener">http://server.url</a>/时（服务器的基本url），路由器会将final/与处理程序函数test匹配，然后返回JSON对象。</p>
<p>SANIC处理程序函数必须使用异步定义语法定义，因为它们是异步函数。</p>
<h2 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h2><p>SANIC附带了一个支持请求参数的基本路由器。</p>
<p>要指定参数，请使用角度引号将其括起来，如so:<param>。请求参数将作为关键字参数传递给路由处理程序函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from sanic.response import text</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/tag/&lt;tag&gt;&apos;)</span><br><span class="line">async def tag_handler(request, tag):</span><br><span class="line">	return text(&apos;Tag - &#123;&#125;&apos;.format(tag))</span><br></pre></td></tr></table></figure>

<p>要为参数指定类型，请在参数名称后面的引号内添加：type。如果参数与指定的类型不匹配，SANIC将引发NotFound异常，导致URL上出现404:Page Not Found错误。</p>
<h3 id="支持的类型"><a href="#支持的类型" class="headerlink" title="支持的类型"></a>支持的类型</h3><ul>
<li>一串<ul>
<li>“鲍勃”</li>
<li>“ Python 3”</li>
</ul>
</li>
<li><code>int</code><ul>
<li>10</li>
<li>20</li>
<li>30</li>
<li>-10</li>
<li>（这里没有浮点数）</li>
</ul>
</li>
<li>数<ul>
<li>1</li>
<li>1.5</li>
<li>10</li>
<li>-10</li>
</ul>
</li>
<li>阿尔法<ul>
<li>“鲍勃”</li>
<li>“ Python ”</li>
<li>（如果它包含符号或非字母数字字符，它将失败）</li>
</ul>
</li>
<li>路径<ul>
<li>“你好”</li>
<li>“hello.text”</li>
<li>“你好，世界”</li>
</ul>
</li>
<li>UUID<ul>
<li>123A123A-A12A-1A1A-A1A1-1A12A1A12345（Uuidv4支持）</li>
</ul>
</li>
<li>正则表达式</li>
</ul>
<p>如果未设置类型，则应为字符串。为函数提供的参数将始终是一个字符串，与类型无关。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">from sanic.response import text</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/string/&lt;string_arg:string&gt;&apos;)</span><br><span class="line">async def string_handler(request, string_arg):</span><br><span class="line">    return text(&apos;String - &#123;&#125;&apos;.format(string_arg))</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/int/&lt;integer_arg:int&gt;&apos;)</span><br><span class="line">async def integer_handler(request, integer_arg):</span><br><span class="line">    return text(&apos;Integer - &#123;&#125;&apos;.format(integer_arg))</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/number/&lt;number_arg:number&gt;&apos;)</span><br><span class="line">async def number_handler(request, number_arg):</span><br><span class="line">    return text(&apos;Number - &#123;&#125;&apos;.format(number_arg))</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/alpha/&lt;alpha_arg:alpha&gt;&apos;)</span><br><span class="line">async def number_handler(request, alpha_arg):</span><br><span class="line">    return text(&apos;Alpha - &#123;&#125;&apos;.format(alpha_arg))</span><br><span class="line">    </span><br><span class="line">@app.route(&apos;/path/&lt;path_arg:path&gt;&apos;)</span><br><span class="line">async def number_handler(request, path_arg):</span><br><span class="line">    return text(&apos;Path - &#123;&#125;&apos;.format(path_arg))</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/uuid/&lt;uuid_arg:uuid&gt;&apos;)</span><br><span class="line">async def number_handler(request, uuid_arg):</span><br><span class="line">    return text(&apos;Uuid - &#123;&#125;&apos;.format(uuid_arg))</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/person/&lt;name:[A-z]+&gt;&apos;)</span><br><span class="line">async def person_handler(request, name):</span><br><span class="line">    return text(&apos;Person - &#123;&#125;&apos;.format(name))</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/folder/&lt;folder_id:[A-z0-9]&#123;0,4&#125;&gt;&apos;)</span><br><span class="line">async def folder_handler(request, folder_id):</span><br><span class="line">    return text(&apos;Folder - &#123;&#125;&apos;.format(folder_id))</span><br></pre></td></tr></table></figure>

<p>警告str不是有效的类型标记。如果需要str识别，则必须使用字符串</p>
<h2 id="HTTP请求类型"><a href="#HTTP请求类型" class="headerlink" title="HTTP请求类型"></a>HTTP请求类型</h2><p>默认情况下，在URL上定义的路由只能用于获取对该URL的请求。但是，@app.route decorator接受一个可选参数methods，它允许handler函数处理列表中的任何http方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from sanic.response import text</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/post&apos;, methods=[&apos;POST&apos;])</span><br><span class="line">async def post_handler(request):</span><br><span class="line">	return text(&apos;POST request - &#123;&#125;&apos;.format(request.json))</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/get&apos;, methods=[&apos;GET&apos;])</span><br><span class="line">async def get_handler(request):</span><br><span class="line">	return text(&apos;GET request - &#123;&#125;&apos;.format(request.args))</span><br></pre></td></tr></table></figure>

<p>还有一个可选的主机参数（可以是列表或字符串）。这将限制到提供的一个或多个主机的路由。如果还有一个没有主机的路由，它将是默认路由。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&apos;/get&apos;, methods=[&apos;GET&apos;], host=&apos;example.com&apos;)</span><br><span class="line">async def get_handler(request):</span><br><span class="line">	return text(&apos;GET request - &#123;&#125;&apos;.format(request.args))</span><br><span class="line"></span><br><span class="line"># if the host header doesn&apos;t match example.com, this route will be used</span><br><span class="line">@app.route(&apos;/get&apos;, methods=[&apos;GET&apos;])</span><br><span class="line">async def get_handler(request):</span><br><span class="line">	return text(&apos;GET request in default - &#123;&#125;&apos;.format(request.args))</span><br></pre></td></tr></table></figure>

<p>还有一些速记方法装饰师：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from sanic.response import text</span><br><span class="line"></span><br><span class="line">@app.post(&apos;/post&apos;)</span><br><span class="line">async def post_handler(request):</span><br><span class="line">	return text(&apos;POST request - &#123;&#125;&apos;.format(request.json))</span><br><span class="line"></span><br><span class="line">@app.get(&apos;/get&apos;)</span><br><span class="line">async def get_handler(request):</span><br><span class="line">	return text(&apos;GET request - &#123;&#125;&apos;.format(request.args))</span><br></pre></td></tr></table></figure>

<h2 id="添加路由方法"><a href="#添加路由方法" class="headerlink" title="添加路由方法"></a>添加路由方法</h2><p>如我们所见，通常使用@app.route decorator指定路由。但是，这个修饰器实际上只是app.add_route方法的包装器，使用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from sanic.response import text</span><br><span class="line"></span><br><span class="line"># Define the handler functions</span><br><span class="line">async def handler1(request):</span><br><span class="line">	return text(&apos;OK&apos;)</span><br><span class="line"></span><br><span class="line">async def handler2(request, name):</span><br><span class="line">	return text(&apos;Folder - &#123;&#125;&apos;.format(name))</span><br><span class="line"></span><br><span class="line">async def person_handler2(request, name):</span><br><span class="line">	return text(&apos;Person - &#123;&#125;&apos;.format(name))</span><br><span class="line"></span><br><span class="line"># Add each handler function as a route</span><br><span class="line">app.add_route(handler1, &apos;/test&apos;)</span><br><span class="line">app.add_route(handler2, &apos;/folder/&lt;name&gt;&apos;)</span><br><span class="line">app.add_route(person_handler2, &apos;/person/&lt;name:[A-z]&gt;&apos;, methods=[&apos;GET&apos;])</span><br></pre></td></tr></table></figure>

<h2 id="带url-的url构建"><a href="#带url-的url构建" class="headerlink" title="带url_的url构建"></a>带url_的url构建</h2><p><a href="https://www.osgeo.cn/sanic/sanic/routing.html#id1" target="_blank" rel="noopener">sanic为方法提供了一个url_</a>，以根据处理程序方法名生成url。如果您希望避免将URL路径硬编码到应用程序中，这很有用；相反，您可以只引用处理程序名称。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from sanic.response import redirect</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">async def index(request):</span><br><span class="line">    # generate a URL for the endpoint `post_handler`</span><br><span class="line">    url = app.url_for(&apos;post_handler&apos;, post_id=5)</span><br><span class="line">    # the URL is `/posts/5`, redirect to it</span><br><span class="line">    return redirect(url)    </span><br><span class="line"></span><br><span class="line">@app.route(&apos;/posts/&lt;post_id&gt;&apos;)</span><br><span class="line">async def post_handler(request, post_id):</span><br><span class="line">    return text(&apos;Post - &#123;&#125;&apos;.format(post_id))</span><br></pre></td></tr></table></figure>

<p>在使用url时要记住的其他事项：</p>
<ul>
<li>传递给url_的不是请求参数的关键字参数将包含在url的查询字符串中。例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url = app.url_for(&apos;post_handler&apos;, post_id=5, arg_one=&apos;one&apos;, arg_two=&apos;two&apos;)</span><br><span class="line"># /posts/5?arg_one=one&amp;arg_two=two</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://www.osgeo.cn/sanic/sanic/routing.html#id3" target="_blank" rel="noopener">可以将多值参数传递给的url_</a>。例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url = app.url_for(&apos;post_handler&apos;, post_id=5, arg_one=[&apos;one&apos;, &apos;two&apos;])</span><br><span class="line"># /posts/5?arg_one=one&amp;arg_one=two</span><br></pre></td></tr></table></figure>

<ul>
<li>另外，传递给url的一些特殊参数（_anchor、_external、_scheme、_method、_server）将具有特殊的url构建（_method现在不受支持，将被忽略）。例如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">url = app.url_for(&apos;post_handler&apos;, post_id=5, arg_one=&apos;one&apos;, _anchor=&apos;anchor&apos;)</span><br><span class="line"># /posts/5?arg_one=one#anchor</span><br><span class="line"></span><br><span class="line">url = app.url_for(&apos;post_handler&apos;, post_id=5, arg_one=&apos;one&apos;, _external=True)</span><br><span class="line"># //server/posts/5?arg_one=one</span><br><span class="line"># _external requires you to pass an argument _server or set SERVER_NAME in app.config if not url will be same as no _external</span><br><span class="line"></span><br><span class="line">url = app.url_for(&apos;post_handler&apos;, post_id=5, arg_one=&apos;one&apos;, _scheme=&apos;http&apos;, _external=True)</span><br><span class="line"># http://server/posts/5?arg_one=one</span><br><span class="line"># when specifying _scheme, _external must be True</span><br><span class="line"></span><br><span class="line"># you can pass all special arguments at once</span><br><span class="line">url = app.url_for(&apos;post_handler&apos;, post_id=5, arg_one=[&apos;one&apos;, &apos;two&apos;], arg_two=2, _anchor=&apos;anchor&apos;, _scheme=&apos;http&apos;, _external=True, _server=&apos;another_server:8888&apos;)</span><br><span class="line"># http://another_server:8888/posts/5?arg_one=one&amp;arg_one=two&amp;arg_two=2#anchor</span><br></pre></td></tr></table></figure>

<ul>
<li>必须将所有有效参数传递到url_才能生成url。如果未提供参数，或者参数与指定的类型不匹配，则将引发urlbuild错误。</li>
</ul>
<h2 id="WebSocket路由"><a href="#WebSocket路由" class="headerlink" title="WebSocket路由"></a>WebSocket路由</h2><p>websocket协议的路由可以通过@app.websocket decorator定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@app.websocket(&apos;/feed&apos;)</span><br><span class="line">async def feed(request, ws):</span><br><span class="line">    while True:</span><br><span class="line">        data = &apos;hello!&apos;</span><br><span class="line">        print(&apos;Sending: &apos; + data)</span><br><span class="line">        await ws.send(data)</span><br><span class="line">        data = await ws.recv()</span><br><span class="line">        print(&apos;Received: &apos; + data)</span><br></pre></td></tr></table></figure>

<p>或者，可以使用app.add_websocket_route方法代替decorator：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async def feed(request, ws):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">app.add_websocket_route(my_websocket_handler, &apos;/feed&apos;)</span><br></pre></td></tr></table></figure>

<p>调用WebSocket路由的处理程序时，请求作为第一个参数，WebSocket协议对象作为第二个参数。协议对象具有分别发送和接收数据的发送和接收方法。</p>
<p>WebSocket支持需要Aymeri Augustin提供的WebSockets包。</p>
<h2 id="关于严格的削减"><a href="#关于严格的削减" class="headerlink" title="关于严格的削减"></a>关于严格的削减</h2><p>您可以使路由严格到尾随斜线，或者不严格到尾随斜线，这是可配置的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># provide default strict_slashes value for all routes</span><br><span class="line">app = Sanic(&apos;test_route_strict_slash&apos;, strict_slashes=True)</span><br><span class="line"></span><br><span class="line"># you can also overwrite strict_slashes value for specific route</span><br><span class="line">@app.get(&apos;/get&apos;, strict_slashes=False)</span><br><span class="line">def handler(request):</span><br><span class="line">    return text(&apos;OK&apos;)</span><br><span class="line"></span><br><span class="line"># It also works for blueprints</span><br><span class="line">bp = Blueprint(&apos;test_bp_strict_slash&apos;, strict_slashes=True)</span><br><span class="line"></span><br><span class="line">@bp.get(&apos;/bp/get&apos;, strict_slashes=False)</span><br><span class="line">def handler(request):</span><br><span class="line">    return text(&apos;OK&apos;)</span><br><span class="line"></span><br><span class="line">app.blueprint(bp)</span><br></pre></td></tr></table></figure>

<p>严格斜杠标志如何遵循定义的层次结构的行为，该层次结构决定特定路由是否属于严格斜杠行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|___ Route</span><br><span class="line">     |___ Blueprint</span><br><span class="line">            |___ Application</span><br></pre></td></tr></table></figure>

<p>上面的层次结构定义了“严格斜杠”标志的行为方式。上述顺序中找到的第一个严格斜线的非“无”值将应用于有问题的路由。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from sanic import Sanic, Blueprint</span><br><span class="line">from sanic.response import text</span><br><span class="line"></span><br><span class="line">app = Sanic(&quot;sample_strict_slashes&quot;, strict_slashes=True)</span><br><span class="line"></span><br><span class="line">@app.get(&quot;/r1&quot;)</span><br><span class="line">def r1(request):</span><br><span class="line">    return text(&quot;strict_slashes is applicable from App level&quot;)</span><br><span class="line"></span><br><span class="line">@app.get(&quot;/r2&quot;, strict_slashes=False)</span><br><span class="line">def r2(request):</span><br><span class="line">    return text(&quot;strict_slashes is not applicable due to  False value set in route level&quot;)</span><br><span class="line"></span><br><span class="line">bp = Blueprint(&quot;bp&quot;, strict_slashes=False)</span><br><span class="line"></span><br><span class="line">@bp.get(&quot;/r3&quot;, strict_slashes=True)</span><br><span class="line">def r3(request):</span><br><span class="line">    return text(&quot;strict_slashes applicable from blueprint route level&quot;)</span><br><span class="line"></span><br><span class="line">bp1 = Blueprint(&quot;bp1&quot;, strict_slashes=True)</span><br><span class="line"></span><br><span class="line">@bp.get(&quot;/r4&quot;)</span><br><span class="line">def r3(request):</span><br><span class="line">    return text(&quot;strict_slashes applicable from blueprint level&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="用户定义的路由名称"><a href="#用户定义的路由名称" class="headerlink" title="用户定义的路由名称"></a>用户定义的路由名称</h2><p>可以通过在注册路由时传递名称参数来使用自定义路由名称，该参数将覆盖使用 handler.<strong>name</strong> 属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">app = Sanic(&apos;test_named_route&apos;)</span><br><span class="line"></span><br><span class="line">@app.get(&apos;/get&apos;, name=&apos;get_handler&apos;)</span><br><span class="line">def handler(request):</span><br><span class="line">    return text(&apos;OK&apos;)</span><br><span class="line"></span><br><span class="line"># then you need use `app.url_for(&apos;get_handler&apos;)`</span><br><span class="line"># instead of # `app.url_for(&apos;handler&apos;)`</span><br><span class="line"></span><br><span class="line"># It also works for blueprints</span><br><span class="line">bp = Blueprint(&apos;test_named_bp&apos;)</span><br><span class="line"></span><br><span class="line">@bp.get(&apos;/bp/get&apos;, name=&apos;get_handler&apos;)</span><br><span class="line">def handler(request):</span><br><span class="line">    return text(&apos;OK&apos;)</span><br><span class="line"></span><br><span class="line">app.blueprint(bp)</span><br><span class="line"></span><br><span class="line"># then you need use `app.url_for(&apos;test_named_bp.get_handler&apos;)`</span><br><span class="line"># instead of `app.url_for(&apos;test_named_bp.handler&apos;)`</span><br><span class="line"></span><br><span class="line"># different names can be used for same url with different methods</span><br><span class="line"></span><br><span class="line">@app.get(&apos;/test&apos;, name=&apos;route_test&apos;)</span><br><span class="line">def handler(request):</span><br><span class="line">    return text(&apos;OK&apos;)</span><br><span class="line"></span><br><span class="line">@app.post(&apos;/test&apos;, name=&apos;route_post&apos;)</span><br><span class="line">def handler2(request):</span><br><span class="line">    return text(&apos;OK POST&apos;)</span><br><span class="line"></span><br><span class="line">@app.put(&apos;/test&apos;, name=&apos;route_put&apos;)</span><br><span class="line">def handler3(request):</span><br><span class="line">    return text(&apos;OK PUT&apos;)</span><br><span class="line"></span><br><span class="line"># below url are the same, you can use any of them</span><br><span class="line"># &apos;/test&apos;</span><br><span class="line">app.url_for(&apos;route_test&apos;)</span><br><span class="line"># app.url_for(&apos;route_post&apos;)</span><br><span class="line"># app.url_for(&apos;route_put&apos;)</span><br><span class="line"></span><br><span class="line"># for same handler name with different methods</span><br><span class="line"># you need specify the name (it&apos;s url_for issue)</span><br><span class="line">@app.get(&apos;/get&apos;)</span><br><span class="line">def handler(request):</span><br><span class="line">    return text(&apos;OK&apos;)</span><br><span class="line"></span><br><span class="line">@app.post(&apos;/post&apos;, name=&apos;post_handler&apos;)</span><br><span class="line">def handler(request):</span><br><span class="line">    return text(&apos;OK&apos;)</span><br><span class="line"></span><br><span class="line"># then</span><br><span class="line"># app.url_for(&apos;handler&apos;) == &apos;/get&apos;</span><br><span class="line"># app.url_for(&apos;post_handler&apos;) == &apos;/post&apos;</span><br></pre></td></tr></table></figure>

<h2 id="为静态文件生成URL"><a href="#为静态文件生成URL" class="headerlink" title="为静态文件生成URL"></a>为静态文件生成URL</h2><p>SANIC支持使用url_生成静态文件url的方法。如果静态URL指向某个目录，则可以忽略URL_的文件名参数。Q</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">app = Sanic(&apos;test_static&apos;)</span><br><span class="line">app.static(&apos;/static&apos;, &apos;./static&apos;)</span><br><span class="line">app.static(&apos;/uploads&apos;, &apos;./uploads&apos;, name=&apos;uploads&apos;)</span><br><span class="line">app.static(&apos;/the_best.png&apos;, &apos;/home/ubuntu/test.png&apos;, name=&apos;best_png&apos;)</span><br><span class="line"></span><br><span class="line">bp = Blueprint(&apos;bp&apos;, url_prefix=&apos;bp&apos;)</span><br><span class="line">bp.static(&apos;/static&apos;, &apos;./static&apos;)</span><br><span class="line">bp.static(&apos;/uploads&apos;, &apos;./uploads&apos;, name=&apos;uploads&apos;)</span><br><span class="line">bp.static(&apos;/the_best.png&apos;, &apos;/home/ubuntu/test.png&apos;, name=&apos;best_png&apos;)</span><br><span class="line">app.blueprint(bp)</span><br><span class="line"></span><br><span class="line"># then build the url</span><br><span class="line">app.url_for(&apos;static&apos;, filename=&apos;file.txt&apos;) == &apos;/static/file.txt&apos;</span><br><span class="line">app.url_for(&apos;static&apos;, name=&apos;static&apos;, filename=&apos;file.txt&apos;) == &apos;/static/file.txt&apos;</span><br><span class="line">app.url_for(&apos;static&apos;, name=&apos;uploads&apos;, filename=&apos;file.txt&apos;) == &apos;/uploads/file.txt&apos;</span><br><span class="line">app.url_for(&apos;static&apos;, name=&apos;best_png&apos;) == &apos;/the_best.png&apos;</span><br><span class="line"></span><br><span class="line"># blueprint url building</span><br><span class="line">app.url_for(&apos;static&apos;, name=&apos;bp.static&apos;, filename=&apos;file.txt&apos;) == &apos;/bp/static/file.txt&apos;</span><br><span class="line">app.url_for(&apos;static&apos;, name=&apos;bp.uploads&apos;, filename=&apos;file.txt&apos;) == &apos;/bp/uploads/file.txt&apos;</span><br><span class="line">app.url_for(&apos;static&apos;, name=&apos;bp.best_png&apos;) == &apos;/bp/static/the_best.png&apos;</span><br></pre></td></tr></table></figure>

<h1 id="蓝图blue"><a href="#蓝图blue" class="headerlink" title="蓝图blue"></a>蓝图blue</h1><p>蓝图是可以在应用程序中用于子路由的对象。蓝图不是向应用程序实例添加路由，而是定义类似的方法来添加路由，然后以灵活且可插入的方式向应用程序注册路由。</p>
<p>蓝图对于更大的应用程序特别有用，在这些应用程序中，可以将应用程序逻辑分解为多个组或职责区域。</p>
<h2 id="我的第一张蓝图"><a href="#我的第一张蓝图" class="headerlink" title="我的第一张蓝图"></a>我的第一张蓝图</h2><p>下面显示了一个非常简单的蓝图，它在应用程序的根目录/注册一个处理程序函数。</p>
<p>假设您将此文件保存为my_blueprint.py，稍后可以导入主应用程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from sanic.response import json</span><br><span class="line">from sanic import Blueprint</span><br><span class="line"></span><br><span class="line">bp = Blueprint(&apos;my_blueprint&apos;)</span><br><span class="line"></span><br><span class="line">@bp.route(&apos;/&apos;)</span><br><span class="line">async def bp_root(request):</span><br><span class="line">    return json(&#123;&apos;my&apos;: &apos;blueprint&apos;&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="正在注册蓝图"><a href="#正在注册蓝图" class="headerlink" title="正在注册蓝图"></a>正在注册蓝图</h2><p>蓝图必须在应用程序中注册。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from sanic import Sanic</span><br><span class="line">from my_blueprint import bp</span><br><span class="line"></span><br><span class="line">app = Sanic(__name__)</span><br><span class="line">app.blueprint(bp)</span><br><span class="line"></span><br><span class="line">app.run(host=&apos;0.0.0.0&apos;, port=8000, debug=True)</span><br></pre></td></tr></table></figure>

<p>这将把蓝图添加到应用程序中，并注册该蓝图定义的任何路由。在本例中，app.router中注册的路由如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Route(handler=&lt;function bp_root at 0x7f908382f9d8&gt;, methods=frozenset(&#123;&apos;GET&apos;&#125;), pattern=re.compile(&apos;^/$&apos;), parameters=[], name=&apos;my_blueprint.bp_root&apos;, uri=&apos;/&apos;)]</span><br></pre></td></tr></table></figure>

<h2 id="蓝图组和嵌套"><a href="#蓝图组和嵌套" class="headerlink" title="蓝图组和嵌套"></a>蓝图组和嵌套</h2><p>蓝图也可以注册为列表或元组的一部分，注册器将在蓝图的任何子序列中循环并相应地注册它们。Blueprint.group方法用于简化此过程，允许模拟前端看到的后端目录结构。考虑一下这个（相当做作的）例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">api/</span><br><span class="line">├──content/</span><br><span class="line">│  ├──authors.py</span><br><span class="line">│  ├──static.py</span><br><span class="line">│  └──__init__.py</span><br><span class="line">├──info.py</span><br><span class="line">└──__init__.py</span><br><span class="line">app.py</span><br></pre></td></tr></table></figure>

<p>此应用的蓝图层次结构的初始化过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># api/content/authors.py</span><br><span class="line">from sanic import Blueprint</span><br><span class="line"></span><br><span class="line">authors = Blueprint(&apos;content_authors&apos;, url_prefix=&apos;/authors&apos;)</span><br><span class="line"># api/content/static.py</span><br><span class="line">from sanic import Blueprint</span><br><span class="line"></span><br><span class="line">static = Blueprint(&apos;content_static&apos;, url_prefix=&apos;/static&apos;)</span><br><span class="line"># api/content/__init__.py</span><br><span class="line">from sanic import Blueprint</span><br><span class="line"></span><br><span class="line">from .static import static</span><br><span class="line">from .authors import authors</span><br><span class="line"></span><br><span class="line">content = Blueprint.group(static, authors, url_prefix=&apos;/content&apos;)</span><br><span class="line"># api/info.py</span><br><span class="line">from sanic import Blueprint</span><br><span class="line"></span><br><span class="line">info = Blueprint(&apos;info&apos;, url_prefix=&apos;/info&apos;)</span><br><span class="line"># api/__init__.py</span><br><span class="line">from sanic import Blueprint</span><br><span class="line"></span><br><span class="line">from .content import content</span><br><span class="line">from .info import info</span><br><span class="line"></span><br><span class="line">api = Blueprint.group(content, info, url_prefix=&apos;/api&apos;)</span><br></pre></td></tr></table></figure>

<p>现在可以这样在app.py中注册这些蓝图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># app.py</span><br><span class="line">from sanic import Sanic</span><br><span class="line"></span><br><span class="line">from .api import api</span><br><span class="line"></span><br><span class="line">app = Sanic(__name__)</span><br><span class="line"></span><br><span class="line">app.blueprint(api)</span><br></pre></td></tr></table></figure>

<h2 id="使用蓝图"><a href="#使用蓝图" class="headerlink" title="使用蓝图"></a>使用蓝图</h2><p>蓝图与应用程序实例具有几乎相同的功能。</p>
<h3 id="WebSocket路由-1"><a href="#WebSocket路由-1" class="headerlink" title="WebSocket路由"></a>WebSocket路由</h3><p>可以使用@bp.websocket decorator或bp.add_websocket_route方法在蓝图上注册websocket处理程序。</p>
<h3 id="蓝图中间件"><a href="#蓝图中间件" class="headerlink" title="蓝图中间件"></a>蓝图中间件</h3><p>使用蓝图还允许您全局注册中间件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@bp.middleware</span><br><span class="line">async def print_on_request(request):</span><br><span class="line">	print(&quot;I am a spy&quot;)</span><br><span class="line"></span><br><span class="line">@bp.middleware(&apos;request&apos;)</span><br><span class="line">async def halt_request(request):</span><br><span class="line">	return text(&apos;I halted the request&apos;)</span><br><span class="line"></span><br><span class="line">@bp.middleware(&apos;response&apos;)</span><br><span class="line">async def halt_response(request, response):</span><br><span class="line">	return text(&apos;I halted the response&apos;)</span><br></pre></td></tr></table></figure>

<h3 id="蓝图组中间件"><a href="#蓝图组中间件" class="headerlink" title="蓝图组中间件"></a>蓝图组中间件</h3><p>使用此中间件将确保您可以将通用中间件应用于构成当前考虑中的蓝图组的所有蓝图。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">bp1 = Blueprint(&apos;bp1&apos;, url_prefix=&apos;/bp1&apos;)</span><br><span class="line">bp2 = Blueprint(&apos;bp2&apos;, url_prefix=&apos;/bp2&apos;)</span><br><span class="line"></span><br><span class="line">@bp1.middleware(&apos;request&apos;)</span><br><span class="line">async def bp1_only_middleware(request):</span><br><span class="line">    print(&apos;applied on Blueprint : bp1 Only&apos;)</span><br><span class="line"></span><br><span class="line">@bp1.route(&apos;/&apos;)</span><br><span class="line">async def bp1_route(request):</span><br><span class="line">    return text(&apos;bp1&apos;)</span><br><span class="line"></span><br><span class="line">@bp2.route(&apos;/&lt;param&gt;&apos;)</span><br><span class="line">async def bp2_route(request, param):</span><br><span class="line">    return text(param)</span><br><span class="line"></span><br><span class="line">group = Blueprint.group(bp1, bp2)</span><br><span class="line"></span><br><span class="line">@group.middleware(&apos;request&apos;)</span><br><span class="line">async def group_middleware(request):</span><br><span class="line">    print(&apos;common middleware applied for both bp1 and bp2&apos;)</span><br><span class="line">    </span><br><span class="line"># Register Blueprint group under the app</span><br><span class="line">app.blueprint(group)</span><br></pre></td></tr></table></figure>

<h3 id="例外情况"><a href="#例外情况" class="headerlink" title="例外情况"></a>例外情况</h3><p>例外情况只能应用于全局蓝图。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@bp.exception(NotFound)</span><br><span class="line">def ignore_404s(request, exception):</span><br><span class="line">	return text(&quot;Yep, I totally found the page: &#123;&#125;&quot;.format(request.url))</span><br></pre></td></tr></table></figure>

<h3 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h3><p>静态文件可以在蓝图前缀下全局提供服务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># suppose bp.name == &apos;bp&apos;</span><br><span class="line"></span><br><span class="line">bp.static(&apos;/web/path&apos;, &apos;/folder/to/serve&apos;)</span><br><span class="line"># also you can pass name parameter to it for url_for</span><br><span class="line">bp.static(&apos;/web/path&apos;, &apos;/folder/to/server&apos;, name=&apos;uploads&apos;)</span><br><span class="line">app.url_for(&apos;static&apos;, name=&apos;bp.uploads&apos;, filename=&apos;file.txt&apos;) == &apos;/bp/web/path/file.txt&apos;</span><br></pre></td></tr></table></figure>

<h2 id="启停"><a href="#启停" class="headerlink" title="启停"></a>启停</h2><p>蓝图可以在服务器的启动和停止过程中运行函数。如果在多处理器模式下运行（超过1个工作进程），则在工作进程分叉后触发。</p>
<p>可用事件包括：</p>
<ul>
<li>在服务器启动之前：在服务器开始接受连接之前执行</li>
<li>服务器启动后：服务器开始接受连接后执行</li>
<li>在服务器停止之前：在服务器停止接受连接之前执行</li>
<li>服务器停止后：在服务器停止且所有请求完成后执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bp = Blueprint(&apos;my_blueprint&apos;)</span><br><span class="line"></span><br><span class="line">@bp.listener(&apos;before_server_start&apos;)</span><br><span class="line">async def setup_connection(app, loop):</span><br><span class="line">    global database</span><br><span class="line">    database = mysql.connect(host=&apos;127.0.0.1&apos;...)</span><br><span class="line"></span><br><span class="line">@bp.listener(&apos;after_server_stop&apos;)</span><br><span class="line">async def close_connection(app, loop):</span><br><span class="line">    await database.close()</span><br></pre></td></tr></table></figure>

<h2 id="用例：API版本控制"><a href="#用例：API版本控制" class="headerlink" title="用例：API版本控制"></a>用例：API版本控制</h2><p>蓝图对于API版本化非常有用，其中一个蓝图可能指向/v1/<routes>，另一个蓝图指向/v2/<routes>。</routes></routes></p>
<p>当一个蓝图初始化时，它可以接受一个可选的版本参数，该参数将被预先附加到蓝图上定义的所有路由上。这个特性可以用来实现我们的API版本控制方案。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># blueprints.py</span><br><span class="line">from sanic.response import text</span><br><span class="line">from sanic import Blueprint</span><br><span class="line"></span><br><span class="line">blueprint_v1 = Blueprint(&apos;v1&apos;, url_prefix=&apos;/api&apos;, version=&quot;v1&quot;)</span><br><span class="line">blueprint_v2 = Blueprint(&apos;v2&apos;, url_prefix=&apos;/api&apos;, version=&quot;v2&quot;)</span><br><span class="line"></span><br><span class="line">@blueprint_v1.route(&apos;/&apos;)</span><br><span class="line">async def api_v1_root(request):</span><br><span class="line">    return text(&apos;Welcome to version 1 of our documentation&apos;)</span><br><span class="line"></span><br><span class="line">@blueprint_v2.route(&apos;/&apos;)</span><br><span class="line">async def api_v2_root(request):</span><br><span class="line">    return text(&apos;Welcome to version 2 of our documentation&apos;)</span><br></pre></td></tr></table></figure>

<p>当我们在应用程序上注册蓝图时，routes/v1/api和/v2/api现在将指向单独的蓝图，这允许为每个api版本创建子站点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># main.py</span><br><span class="line">from sanic import Sanic</span><br><span class="line">from blueprints import blueprint_v1, blueprint_v2</span><br><span class="line"></span><br><span class="line">app = Sanic(__name__)</span><br><span class="line">app.blueprint(blueprint_v1)</span><br><span class="line">app.blueprint(blueprint_v2)</span><br><span class="line"></span><br><span class="line">app.run(host=&apos;0.0.0.0&apos;, port=8000, debug=True)</span><br></pre></td></tr></table></figure>

<h2 id="带url-的url构建-1"><a href="#带url-的url构建-1" class="headerlink" title="带url_的url构建"></a>带url_的url构建</h2><p>如果要为蓝图内的路由生成URL，请记住端点名称采用的格式为<blueprint_name><handler_name>。例如：</handler_name></blueprint_name></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@blueprint_v1.route(&apos;/&apos;)</span><br><span class="line">async def root(request):</span><br><span class="line">    url = request.app.url_for(&apos;v1.post_handler&apos;, post_id=5) # --&gt; &apos;/v1/api/post/5&apos;</span><br><span class="line">    return redirect(url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@blueprint_v1.route(&apos;/post/&lt;post_id&gt;&apos;)</span><br><span class="line">async def post_handler(request, post_id):</span><br><span class="line">    return text(&apos;Post &#123;&#125; in Blueprint V1&apos;.format(post_id))</span><br></pre></td></tr></table></figure>

<h1 id="静态文件-1"><a href="#静态文件-1" class="headerlink" title="静态文件"></a>静态文件</h1><p>当用app.static（）方法注册时，SANIC将为静态文件和目录（如图像文件）提供服务。该方法采用一个端点URL和一个文件名。然后，可以通过给定的端点访问指定的文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">from sanic import Sanic</span><br><span class="line">from sanic.blueprints import Blueprint</span><br><span class="line"></span><br><span class="line">app = Sanic(__name__)</span><br><span class="line"></span><br><span class="line"># Serves files from the static folder to the URL /static</span><br><span class="line">app.static(&apos;/static&apos;, &apos;./static&apos;)</span><br><span class="line"># use url_for to build the url, name defaults to &apos;static&apos; and can be ignored</span><br><span class="line">app.url_for(&apos;static&apos;, filename=&apos;file.txt&apos;) == &apos;/static/file.txt&apos;</span><br><span class="line">app.url_for(&apos;static&apos;, name=&apos;static&apos;, filename=&apos;file.txt&apos;) == &apos;/static/file.txt&apos;</span><br><span class="line"></span><br><span class="line"># Serves the file /home/ubuntu/test.png when the URL /the_best.png</span><br><span class="line"># is requested</span><br><span class="line">app.static(&apos;/the_best.png&apos;, &apos;/home/ubuntu/test.png&apos;, name=&apos;best_png&apos;)</span><br><span class="line"></span><br><span class="line"># you can use url_for to build the static file url</span><br><span class="line"># you can ignore name and filename parameters if you don&apos;t define it</span><br><span class="line">app.url_for(&apos;static&apos;, name=&apos;best_png&apos;) == &apos;/the_best.png&apos;</span><br><span class="line">app.url_for(&apos;static&apos;, name=&apos;best_png&apos;, filename=&apos;any&apos;) == &apos;/the_best.png&apos;</span><br><span class="line"></span><br><span class="line"># you need define the name for other static files</span><br><span class="line">app.static(&apos;/another.png&apos;, &apos;/home/ubuntu/another.png&apos;, name=&apos;another&apos;)</span><br><span class="line">app.url_for(&apos;static&apos;, name=&apos;another&apos;) == &apos;/another.png&apos;</span><br><span class="line">app.url_for(&apos;static&apos;, name=&apos;another&apos;, filename=&apos;any&apos;) == &apos;/another.png&apos;</span><br><span class="line"></span><br><span class="line"># also, you can use static for blueprint</span><br><span class="line">bp = Blueprint(&apos;bp&apos;, url_prefix=&apos;/bp&apos;)</span><br><span class="line">bp.static(&apos;/static&apos;, &apos;./static&apos;)</span><br><span class="line"></span><br><span class="line"># servers the file directly</span><br><span class="line">bp.static(&apos;/the_best.png&apos;, &apos;/home/ubuntu/test.png&apos;, name=&apos;best_png&apos;)</span><br><span class="line">app.blueprint(bp)</span><br><span class="line"></span><br><span class="line">app.url_for(&apos;static&apos;, name=&apos;bp.static&apos;, filename=&apos;file.txt&apos;) == &apos;/bp/static/file.txt&apos;</span><br><span class="line">app.url_for(&apos;static&apos;, name=&apos;bp.best_png&apos;) == &apos;/bp/test_best.png&apos;</span><br><span class="line"></span><br><span class="line">app.run(host=&quot;0.0.0.0&quot;, port=8000)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：当您为静态目录提供服务时，SANIC不提供目录索引。</p>
</blockquote>
<h2 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h2><p>app.static（）方法还支持虚拟主机。可以使用主机参数为静态文件提供特定的虚拟主机。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from sanic import Sanic</span><br><span class="line"></span><br><span class="line">app = Sanic(__name__)</span><br><span class="line"></span><br><span class="line">app.static(&apos;/static&apos;, &apos;./static&apos;)</span><br><span class="line">app.static(&apos;/example_static&apos;, &apos;./example_static&apos;, host=&apos;www.example.com&apos;)</span><br></pre></td></tr></table></figure>

<h2 id="流式处理大文件"><a href="#流式处理大文件" class="headerlink" title="流式处理大文件"></a>流式处理大文件</h2><p>在某些情况下，您可能会将大文件（例如：视频、图像等）与sanic一起服务器。您可以选择使用流文件，而不是直接下载。</p>
<p>下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from sanic import Sanic</span><br><span class="line"></span><br><span class="line">app = Sanic(__name__)</span><br><span class="line"></span><br><span class="line">app.static(&apos;/large_video.mp4&apos;, &apos;/home/ubuntu/large_video.mp4&apos;, stream_large_files=True)</span><br></pre></td></tr></table></figure>

<p>当stream_large_files为true时，SANIC将使用file_stream（）而不是file（）来服务静态文件。这将使用1KB作为默认块大小。如果需要，还可以使用自定义块大小。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from sanic import Sanic</span><br><span class="line"></span><br><span class="line">app = Sanic(__name__)</span><br><span class="line"></span><br><span class="line">chunk_size = 1024 * 1024 * 8 # Set chunk size to 8KB</span><br><span class="line">app.static(&apos;/large_video.mp4&apos;, &apos;/home/ubuntu/large_video.mp4&apos;, stream_large_files=chunk_size)</span><br></pre></td></tr></table></figure>

<h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p>sanic在 websockets . 要设置WebSocket：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from sanic import Sanic</span><br><span class="line">from sanic.response import json</span><br><span class="line">from sanic.websocket import WebSocketProtocol</span><br><span class="line"></span><br><span class="line">app = Sanic()</span><br><span class="line"></span><br><span class="line">@app.websocket(&apos;/feed&apos;)</span><br><span class="line">async def feed(request, ws):</span><br><span class="line">    while True:</span><br><span class="line">        data = &apos;hello!&apos;</span><br><span class="line">        print(&apos;Sending: &apos; + data)</span><br><span class="line">        await ws.send(data)</span><br><span class="line">        data = await ws.recv()</span><br><span class="line">        print(&apos;Received: &apos; + data)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app.run(host=&quot;0.0.0.0&quot;, port=8000, protocol=WebSocketProtocol)</span><br></pre></td></tr></table></figure>

<p>或者， <code>app.add_websocket_route</code> 方法可以代替修饰器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async def feed(request, ws):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">app.add_websocket_route(feed, &apos;/feed&apos;)</span><br></pre></td></tr></table></figure>

<p>调用WebSocket路由的处理程序时，请求作为第一个参数，WebSocket协议对象作为第二个参数。协议对象具有 <code>send</code> 和 <code>recv</code> 方法分别发送和接收数据。</p>
<p>您可以通过以下方式设置自己的WebSocket配置： <code>app.config</code> ，像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.config.WEBSOCKET_MAX_SIZE = 2 ** 20</span><br><span class="line">app.config.WEBSOCKET_MAX_QUEUE = 32</span><br><span class="line">app.config.WEBSOCKET_READ_LIMIT = 2 ** 16</span><br><span class="line">app.config.WEBSOCKET_WRITE_LIMIT = 2 ** 16</span><br></pre></td></tr></table></figure>

<p>发现更多 <code>Configuration</code> 部分。</p>
<h1 id="处理程序装饰器"><a href="#处理程序装饰器" class="headerlink" title="处理程序装饰器"></a>处理程序装饰器</h1><p>由于sanic处理程序是简单的python函数，所以可以以类似于flask的方式将修饰器应用于它们。一个典型的用例是，当您希望在执行处理程序的代码之前运行一些代码时。</p>
<h2 id="授权修饰器"><a href="#授权修饰器" class="headerlink" title="授权修饰器"></a>授权修饰器</h2><p>假设您希望检查用户是否有权访问特定端点。您可以创建一个包装处理程序函数的装饰器，检查客户机是否有权访问资源，并发送适当的响应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">from functools import wraps</span><br><span class="line">from sanic.response import json</span><br><span class="line"></span><br><span class="line">def authorized():</span><br><span class="line">    def decorator(f):</span><br><span class="line">        @wraps(f)</span><br><span class="line">        async def decorated_function(request, *args, **kwargs):</span><br><span class="line">            # run some method that checks the request</span><br><span class="line">            # for the client&apos;s authorization status</span><br><span class="line">            is_authorized = check_request_for_authorization_status(request)</span><br><span class="line"></span><br><span class="line">            if is_authorized:</span><br><span class="line">                # the user is authorized.</span><br><span class="line">                # run the handler method and return the response</span><br><span class="line">                response = await f(request, *args, **kwargs)</span><br><span class="line">                return response</span><br><span class="line">            else:</span><br><span class="line">                # the user is not authorized. </span><br><span class="line">                return json(&#123;&apos;status&apos;: &apos;not_authorized&apos;&#125;, 403)</span><br><span class="line">        return decorated_function</span><br><span class="line">    return decorator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&quot;)</span><br><span class="line">@authorized()</span><br><span class="line">async def test(request):</span><br><span class="line">    return json(&#123;&apos;status&apos;: &apos;authorized&apos;&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="基于类的视图"><a href="#基于类的视图" class="headerlink" title="基于类的视图"></a>基于类的视图</h1><p>基于类的视图只是实现对请求的响应行为的类。它们提供了一种在同一端点划分不同HTTP请求类型处理的方法。可以为端点分配一个基于类的视图，而不是定义和修饰三个不同的处理程序函数（每个端点支持的请求类型对应一个处理程序函数）。</p>
<h2 id="定义视图"><a href="#定义视图" class="headerlink" title="定义视图"></a>定义视图</h2><p>基于类的视图应该是httpMethodView的子类。然后，您可以为想要支持的每个HTTP请求类型实现类方法。如果接收到没有定义方法的请求，将生成405:方法不允许的响应。</p>
<p>要在端点上注册基于类的视图，请使用app.add_route方法。第一个参数应该是已定义的类，方法为“view invoked”，第二个参数应该是URL端点。</p>
<p>可用的方法有get、post、put、patch和delete。使用所有这些方法的类如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from sanic import Sanic</span><br><span class="line">from sanic.views import HTTPMethodView</span><br><span class="line">from sanic.response import text</span><br><span class="line"></span><br><span class="line">app = Sanic(&apos;some_name&apos;)</span><br><span class="line"></span><br><span class="line">class SimpleView(HTTPMethodView):</span><br><span class="line"></span><br><span class="line">  def get(self, request):</span><br><span class="line">      return text(&apos;I am get method&apos;)</span><br><span class="line"></span><br><span class="line">  def post(self, request):</span><br><span class="line">      return text(&apos;I am post method&apos;)</span><br><span class="line"></span><br><span class="line">  def put(self, request):</span><br><span class="line">      return text(&apos;I am put method&apos;)</span><br><span class="line"></span><br><span class="line">  def patch(self, request):</span><br><span class="line">      return text(&apos;I am patch method&apos;)</span><br><span class="line"></span><br><span class="line">  def delete(self, request):</span><br><span class="line">      return text(&apos;I am delete method&apos;)</span><br><span class="line"></span><br><span class="line">app.add_route(SimpleView.as_view(), &apos;/&apos;)</span><br></pre></td></tr></table></figure>

<p>您也可以使用异步语法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from sanic import Sanic</span><br><span class="line">from sanic.views import HTTPMethodView</span><br><span class="line">from sanic.response import text</span><br><span class="line"></span><br><span class="line">app = Sanic(&apos;some_name&apos;)</span><br><span class="line"></span><br><span class="line">class SimpleAsyncView(HTTPMethodView):</span><br><span class="line"></span><br><span class="line">  async def get(self, request):</span><br><span class="line">      return text(&apos;I am async get method&apos;)</span><br><span class="line"></span><br><span class="line">app.add_route(SimpleAsyncView.as_view(), &apos;/&apos;)</span><br></pre></td></tr></table></figure>

<h2 id="URL参数"><a href="#URL参数" class="headerlink" title="URL参数"></a>URL参数</h2><p>如果您需要任何URL参数（如《路由指南》中所述），请将它们包括在方法定义中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class NameView(HTTPMethodView):</span><br><span class="line"></span><br><span class="line">  def get(self, request, name):</span><br><span class="line">    return text(&apos;Hello &#123;&#125;&apos;.format(name))</span><br><span class="line"></span><br><span class="line">app.add_route(NameView.as_view(), &apos;/&lt;name&gt;&apos;)</span><br></pre></td></tr></table></figure>

<h2 id="装饰者"><a href="#装饰者" class="headerlink" title="装饰者"></a>装饰者</h2><p>如果要向类中添加任何修饰符，可以设置decorators类变量。这些将在调用as-view时应用于类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ViewWithDecorator(HTTPMethodView):</span><br><span class="line">  decorators = [some_decorator_here]</span><br><span class="line"></span><br><span class="line">  def get(self, request, name):</span><br><span class="line">    return text(&apos;Hello I have a decorator&apos;)</span><br><span class="line"></span><br><span class="line">  def post(self, request, name):</span><br><span class="line">    return text(&quot;Hello I also have a decorator&quot;)</span><br><span class="line"></span><br><span class="line">app.add_route(ViewWithDecorator.as_view(), &apos;/url&apos;)</span><br></pre></td></tr></table></figure>

<p>但是如果你只想装饰一些功能，而不是所有的功能，你可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class ViewWithSomeDecorator(HTTPMethodView):</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    @some_decorator_here</span><br><span class="line">    def get(request, name):</span><br><span class="line">        return text(&quot;Hello I have a decorator&quot;)</span><br><span class="line"></span><br><span class="line">    def post(self, request, name):</span><br><span class="line">        return text(&quot;Hello I don&apos;t have any decorators&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="网址构建"><a href="#网址构建" class="headerlink" title="网址构建"></a>网址构建</h2><p>如果您希望为httpmethodview构建一个URL，请记住类名将是您将传递到url_的端点。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def index(request):</span><br><span class="line">    url = app.url_for(&apos;SpecialClassView&apos;)</span><br><span class="line">    return redirect(url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SpecialClassView(HTTPMethodView):</span><br><span class="line">    def get(self, request):</span><br><span class="line">        return text(&apos;Hello from the Special Class View!&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.add_route(SpecialClassView.as_view(), &apos;/special_class_view&apos;)</span><br></pre></td></tr></table></figure>

<h2 id="使用合成视图"><a href="#使用合成视图" class="headerlink" title="使用合成视图"></a>使用合成视图</h2><p>作为httpMethodView的替代方法，可以使用compositionView将处理程序函数移动到视图类之外。</p>
<p>每个支持的HTTP方法的处理程序函数在源代码的其他地方定义，然后使用compositionview.add方法添加到视图中。第一个参数是要处理的HTTP方法列表（例如 [“得到”，“邮寄”] ，第二个是处理函数。下面的示例显示了对外部处理程序函数和内联lambda的compositionview用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from sanic import Sanic</span><br><span class="line">from sanic.views import CompositionView</span><br><span class="line">from sanic.response import text</span><br><span class="line"></span><br><span class="line">app = Sanic(__name__)</span><br><span class="line"></span><br><span class="line">def get_handler(request):</span><br><span class="line">    return text(&apos;I am a get method&apos;)</span><br><span class="line"></span><br><span class="line">view = CompositionView()</span><br><span class="line">view.add([&apos;GET&apos;], get_handler)</span><br><span class="line">view.add([&apos;POST&apos;, &apos;PUT&apos;], lambda request: text(&apos;I am a post/put method&apos;))</span><br><span class="line"></span><br><span class="line"># Use the new view to handle requests to the base URL</span><br><span class="line">app.add_route(view, &apos;/&apos;)</span><br></pre></td></tr></table></figure>

<p>注意：当前无法使用url_为合成视图生成url。</p>
<h1 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h1><p>当启用SANIC的调试模式时，SANIC将提供更详细的日志记录输出，默认情况下将启用自动重新加载功能。</p>
<p>警告</p>
<p>SANIC的更多调试将降低服务器的性能，因此建议仅在开发环境中启用它。</p>
<h2 id="设置调试模式"><a href="#设置调试模式" class="headerlink" title="设置调试模式"></a>设置调试模式</h2><p>通过设置 <code>debug</code> 模式将输出来自SANIC的更详细的输出，并激活自动重新加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from sanic import Sanic</span><br><span class="line">from sanic.response import json</span><br><span class="line"></span><br><span class="line">app = Sanic()</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">async def hello_world(request):</span><br><span class="line">    return json(&#123;&quot;hello&quot;: &quot;world&quot;&#125;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(host=&quot;0.0.0.0&quot;, port=8000, debug=True)</span><br></pre></td></tr></table></figure>

<h2 id="手动设置自动重新加载"><a href="#手动设置自动重新加载" class="headerlink" title="手动设置自动重新加载"></a>手动设置自动重新加载</h2><p>SANIC提供了一种手动启用或禁用自动重新加载的方法，即 <code>auto_reload</code> 参数将激活或停用自动重新加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from sanic import Sanic</span><br><span class="line">from sanic.response import json</span><br><span class="line"></span><br><span class="line">app = Sanic()</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">async def hello_world(request):</span><br><span class="line">    return json(&#123;&quot;hello&quot;: &quot;world&quot;&#125;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(host=&quot;0.0.0.0&quot;, port=8000, auto_reload=True)</span><br></pre></td></tr></table></figure>

<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>SANIC端点可以使用测试客户机对象在本地进行测试，该对象依赖于附加的请求异步库，它实现了一个反映请求库的API。</p>
<p>测试客户机公开了GET、POST、PUT、DELETE、PATCH、HEAD和OPTIONS方法，供您针对应用程序运行。一个简单的例子（使用pytest）如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Import the Sanic app, usually created with Sanic(__name__)</span><br><span class="line">from external_server import app</span><br><span class="line"></span><br><span class="line">def test_index_returns_200():</span><br><span class="line">    request, response = app.test_client.get(&apos;/&apos;)</span><br><span class="line">    assert response.status == 200</span><br><span class="line"></span><br><span class="line">def test_index_put_not_allowed():</span><br><span class="line">    request, response = app.test_client.put(&apos;/&apos;)</span><br><span class="line">    assert response.status == 405</span><br></pre></td></tr></table></figure>

<p>在内部，每次调用一个测试客户机方法时，SANIC应用程序都在127.0.0.1:42101运行，并使用异步请求对应用程序执行测试请求。</p>
<p>测试客户机方法接受以下参数和关键字参数：</p>
<ul>
<li>uri（默认值“/”）表示要测试的uri的字符串。</li>
<li>收集请求（默认为真）一个布尔值，用于确定函数是否返回原始请求。如果设置为true，则返回值是（请求、响应）的元组，如果为false，则仅返回响应。</li>
<li>server_kwargs*（默认值）运行测试请求之前传递到app.run的附加参数的dict。</li>
<li>debug（默认为false）确定是否在调试模式下运行服务器的布尔值。</li>
</ul>
<p>该函数进一步采用 <a href="https://www.osgeo.cn/sanic/sanic/testing.html#id1" target="_blank" rel="noopener">*</a>request_args and * <a href="https://www.osgeo.cn/sanic/sanic/testing.html#id3" target="_blank" rel="noopener">*</a>请求关卡，直接传递给请求。</p>
<p>例如，要向GET请求提供数据，请执行以下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def test_get_request_includes_data():</span><br><span class="line">    params = &#123;&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;&#125;</span><br><span class="line">    request, response = app.test_client.get(&apos;/&apos;, params=params)</span><br><span class="line">    assert request.args.get(&apos;key1&apos;) == &apos;value1&apos;</span><br></pre></td></tr></table></figure>

<p>并向JSON POST请求提供数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def test_post_json_request_includes_data():</span><br><span class="line">    data = &#123;&apos;key1&apos;: &apos;value1&apos;, &apos;key2&apos;: &apos;value2&apos;&#125;</span><br><span class="line">    request, response = app.test_client.post(&apos;/&apos;, data=json.dumps(data))</span><br><span class="line">    assert request.json.get(&apos;key1&apos;) == &apos;value1&apos;</span><br></pre></td></tr></table></figure>

<p>有关异步请求的可用参数的详细信息，请参阅请求文档。</p>
<h2 id="使用随机端口"><a href="#使用随机端口" class="headerlink" title="使用随机端口"></a>使用随机端口</h2><p>如果需要使用内核选择的自由非特权端口（而不是sanictestclient的默认端口）进行测试，可以通过指定port=none来进行测试。在大多数系统上，端口将在1024到65535之间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Import the Sanic app, usually created with Sanic(__name__)</span><br><span class="line">from external_server import app</span><br><span class="line">from sanic.testing import SanicTestClient</span><br><span class="line"></span><br><span class="line">def test_index_returns_200():</span><br><span class="line">    request, response = SanicTestClient(app, port=None).get(&apos;/&apos;)</span><br><span class="line">    assert response.status == 200</span><br></pre></td></tr></table></figure>

<h2 id="pytest-sanic"><a href="#pytest-sanic" class="headerlink" title="pytest-sanic"></a>pytest-sanic</h2><p>pytest-sanic 是一个pytest插件，它可以帮助您异步测试代码。只需编写测试，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async def test_sanic_db_find_by_id(app):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Let&apos;s assume that, in db we have,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: &quot;123&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;Kobe Bryant&quot;,</span><br><span class="line">            &quot;team&quot;: &quot;Lakers&quot;,</span><br><span class="line">        &#125;</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    doc = await app.db[&quot;players&quot;].find_by_id(&quot;123&quot;)</span><br><span class="line">    assert doc.name == &quot;Kobe Bryant&quot;</span><br><span class="line">    assert doc.team == &quot;Lakers&quot;</span><br></pre></td></tr></table></figure>

<p>pytest-sanic还提供一些有用的功能，比如循环、未使用的端口、测试服务器、测试客户机。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">@pytest.yield_fixture</span><br><span class="line">def app():</span><br><span class="line">    app = Sanic(&quot;test_sanic_app&quot;)</span><br><span class="line"></span><br><span class="line">    @app.route(&quot;/test_get&quot;, methods=[&apos;GET&apos;])</span><br><span class="line">    async def test_get(request):</span><br><span class="line">        return response.json(&#123;&quot;GET&quot;: True&#125;)</span><br><span class="line"></span><br><span class="line">    @app.route(&quot;/test_post&quot;, methods=[&apos;POST&apos;])</span><br><span class="line">    async def test_post(request):</span><br><span class="line">        return response.json(&#123;&quot;POST&quot;: True&#125;)</span><br><span class="line"></span><br><span class="line">    yield app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@pytest.fixture</span><br><span class="line">def test_cli(loop, app, test_client):</span><br><span class="line">    return loop.run_until_complete(test_client(app, protocol=WebSocketProtocol))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#########</span><br><span class="line"># Tests #</span><br><span class="line">#########</span><br><span class="line"></span><br><span class="line">async def test_fixture_test_client_get(test_cli):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    GET request</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    resp = await test_cli.get(&apos;/test_get&apos;)</span><br><span class="line">    assert resp.status == 200</span><br><span class="line">    resp_json = await resp.json()</span><br><span class="line">    assert resp_json == &#123;&quot;GET&quot;: True&#125;</span><br><span class="line"></span><br><span class="line">async def test_fixture_test_client_post(test_cli):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    POST request</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    resp = await test_cli.post(&apos;/test_post&apos;)</span><br><span class="line">    assert resp.status == 200</span><br><span class="line">    resp_json = await resp.json()</span><br><span class="line">    assert resp_json == &#123;&quot;POST&quot;: True&#125;</span><br></pre></td></tr></table></figure>

<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>使用三个选项之一部署SANIC非常简单：内置Web服务器、ASGi Web服务器或Gunicorn。把sanic放在反向代理后面也是很常见的，比如nginx。</p>
<h2 id="通过sanic-webserver运行"><a href="#通过sanic-webserver运行" class="headerlink" title="通过sanic webserver运行"></a>通过sanic webserver运行</h2><p>在定义了sanic.sanic的实例之后，我们可以使用以下关键字参数调用run方法：</p>
<ul>
<li>主机（默认为“127.0.0.1”）：服务器的主机地址。</li>
<li>端口（默认8000）：承载服务器的端口。</li>
<li>调试（默认为假）：启用调试输出（减慢服务器速度）。</li>
<li>ssl（默认无）：sslcontext，用于工作进程的ssl加密。</li>
<li>sock（默认无）：服务器接受连接的套接字。</li>
<li>workers（默认值1）：要生成的工作进程数。</li>
<li>循环（默认无）：异步兼容事件循环。如果没有指定，SANIC将创建自己的事件循环。</li>
<li>协议（默认httpprotocol）：asyncio.protocol的子类。</li>
<li>访问日志（默认为真）：启用登录处理请求（显著降低服务器速度）。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.run(host=&apos;0.0.0.0&apos;, port=1337, access_log=False)</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们决定关闭访问日志以提高性能。</p>
<h3 id="工人"><a href="#工人" class="headerlink" title="工人"></a>工人</h3><p>默认情况下，sanic只使用一个CPU核心在主进程中侦听。要启动果汁，只需在运行参数中指定工人的数量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.run(host=&apos;0.0.0.0&apos;, port=1337, workers=4)</span><br></pre></td></tr></table></figure>

<p>SANIC将自动旋转多个进程并在它们之间路由流量。我们建议尽可能多的员工使用可用的核心。</p>
<h3 id="通过命令运行"><a href="#通过命令运行" class="headerlink" title="通过命令运行"></a>通过命令运行</h3><p>如果您喜欢使用命令行参数，可以通过执行模块来启动SANIC Web服务器。例如，如果在名为server.py的文件中初始化sanic as app，则可以这样运行服务器：</p>
<p>python-m sanic server.app–host=0.0.0.0–port=1337–workers=4</p>
<p>通过这种运行sanic的方式，不需要在python文件中调用app.run。如果这样做，请确保包装它，以便它仅在由解释器直接运行时执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(host=&apos;0.0.0.0&apos;, port=1337, workers=4)</span><br></pre></td></tr></table></figure>

<h2 id="通过ASGi运行"><a href="#通过ASGi运行" class="headerlink" title="通过ASGi运行"></a>通过ASGi运行</h2><p>SANIC也符合ASGI。这意味着您可以使用首选的asgi webserver来运行sanic。ASGi的三个主要实现是daphne、uvicorn和hypercorn。</p>
<p>按照他们的文档寻找正确的方法来运行它们，但是它应该看起来像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">daphne myapp:app</span><br><span class="line">uvicorn myapp:app</span><br><span class="line">hypercorn myapp:app</span><br></pre></td></tr></table></figure>

<p>使用asgi时需要注意的几个事项：</p>
<ol>
<li>使用SANIC WebServer时，WebSockets将使用WebSockets包运行。在asgi模式下，不需要这个包，因为websockets是在asgi服务器中管理的。</li>
<li>asgi lifespan协议只支持两个服务器事件：启动和关闭。SANIC有四种：启动前、启动后、关机前和关机后。因此，在asgi模式下，启动和关闭事件将连续运行，而不是围绕服务器进程开始和结束（因为现在由asgi服务器控制）。因此，最好在服务器启动后和服务器停止前使用。</li>
<li>自SANIC V19.6起，ASGi模式仍处于“beta”状态。</li>
</ol>
<h2 id="通过Gunicorn跑步"><a href="#通过Gunicorn跑步" class="headerlink" title="通过Gunicorn跑步"></a>通过Gunicorn跑步</h2><p>gunicorn“green unicorn”是用于Unix的wsgi HTTP服务器。这是一个前叉工人模型移植自Ruby的独角兽项目。</p>
<p>要使用gunicorn运行sanic应用程序，需要使用特殊的sanic.worker.gunicorn worker for gunicorn worker类参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gunicorn myapp:app --bind 0.0.0.0:1337 --worker-class sanic.worker.GunicornWorker</span><br></pre></td></tr></table></figure>

<p>如果应用程序出现内存泄漏，可以将Gunicorn配置为在处理给定数量的请求后优雅地重新启动工作程序。这是一种帮助限制内存泄漏影响的方便方法。</p>
<p>有关更多信息，请参阅Gunicorn文档。</p>
<h2 id="其他部署注意事项"><a href="#其他部署注意事项" class="headerlink" title="其他部署注意事项"></a>其他部署注意事项</h2><h3 id="在反向代理后面运行"><a href="#在反向代理后面运行" class="headerlink" title="在反向代理后面运行"></a>在反向代理后面运行</h3><p>SANIC可与反向代理（如nginx）一起使用。nginx配置有一个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name example.org;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass http://127.0.0.1:8000;</span><br><span class="line">    proxy_set_header Host $host;</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您想要获得真正的客户机IP，您应该为HTTP头配置x-real-ip和x-forwarded-并将app.config.proxys的计数设置为1；有关详细信息，请参见配置页。</p>
<h3 id="为性能禁用调试日志记录"><a href="#为性能禁用调试日志记录" class="headerlink" title="为性能禁用调试日志记录"></a>为性能禁用调试日志记录</h3><p>要提高性能，请在运行参数中添加debug=false和access_log=false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.run(host=&apos;0.0.0.0&apos;, port=1337, workers=4, debug=False, access_log=False)</span><br></pre></td></tr></table></figure>

<p>通过gunicorn运行，您可以设置环境变量sanic_access_log=“false”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env SANIC_ACCESS_LOG=&quot;False&quot; gunicorn myapp:app --bind 0.0.0.0:1337 --worker-class sanic.worker.GunicornWorker --log-level warning</span><br></pre></td></tr></table></figure>

<p>或者直接重写app config</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.config.ACCESS_LOG = False</span><br></pre></td></tr></table></figure>

<h3 id="异步支持和共享循环"><a href="#异步支持和共享循环" class="headerlink" title="异步支持和共享循环"></a>异步支持和共享循环</h3><p>如果您需要与其他应用程序（尤其是循环）共享SANIC过程，那么这是合适的。但是，请注意，此方法不支持使用多个进程，并且通常不是运行应用程序的首选方法。</p>
<p>以下是一个不完整的示例（请参阅示例中的run_async.py了解更实用的内容）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server = app.create_server(host=&quot;0.0.0.0&quot;, port=8000, return_asyncio_server=True)</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">task = asyncio.ensure_future(server)</span><br><span class="line">loop.run_forever()</span><br></pre></td></tr></table></figure>

<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h3 id="简单应用程序"><a href="#简单应用程序" class="headerlink" title="简单应用程序"></a>简单应用程序</h3><p>一个简单的sanic应用程序 <code>async</code> 方法与 <code>text</code> 和 <code>json</code> 类型响应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">from sanic import Sanic</span><br><span class="line">from sanic import response as res</span><br><span class="line"></span><br><span class="line">app = Sanic(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&quot;)</span><br><span class="line">async def test(req):</span><br><span class="line">    return res.text(&quot;I\&apos;m a teapot&quot;, status=418)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(host=&quot;0.0.0.0&quot;, port=8000)</span><br><span class="line">from sanic import Sanic</span><br><span class="line">from sanic import response</span><br><span class="line"></span><br><span class="line">app = Sanic(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&quot;)</span><br><span class="line">async def test(request):</span><br><span class="line">    return response.json(&#123;&quot;test&quot;: True&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(host=&quot;0.0.0.0&quot;, port=8000)</span><br></pre></td></tr></table></figure>

<h3 id="简单的应用程序-Sanic-Views"><a href="#简单的应用程序-Sanic-Views" class="headerlink" title="简单的应用程序 Sanic Views"></a>简单的应用程序 <code>Sanic Views</code></h3><p>展示简单的使用机制 <code>sanic.viewes.HTTPMethodView</code> 以及将其扩展为提供自定义 <code>async</code> 行为为 <code>view</code> .</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">from sanic import Sanic</span><br><span class="line">from sanic.views import HTTPMethodView</span><br><span class="line">from sanic.response import text</span><br><span class="line"></span><br><span class="line">app = Sanic(&apos;some_name&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SimpleView(HTTPMethodView):</span><br><span class="line"></span><br><span class="line">    def get(self, request):</span><br><span class="line">        return text(&apos;I am get method&apos;)</span><br><span class="line"></span><br><span class="line">    def post(self, request):</span><br><span class="line">        return text(&apos;I am post method&apos;)</span><br><span class="line"></span><br><span class="line">    def put(self, request):</span><br><span class="line">        return text(&apos;I am put method&apos;)</span><br><span class="line"></span><br><span class="line">    def patch(self, request):</span><br><span class="line">        return text(&apos;I am patch method&apos;)</span><br><span class="line"></span><br><span class="line">    def delete(self, request):</span><br><span class="line">        return text(&apos;I am delete method&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SimpleAsyncView(HTTPMethodView):</span><br><span class="line"></span><br><span class="line">    async def get(self, request):</span><br><span class="line">        return text(&apos;I am async get method&apos;)</span><br><span class="line"></span><br><span class="line">    async def post(self, request):</span><br><span class="line">        return text(&apos;I am async post method&apos;)</span><br><span class="line"></span><br><span class="line">    async def put(self, request):</span><br><span class="line">        return text(&apos;I am async put method&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.add_route(SimpleView.as_view(), &apos;/&apos;)</span><br><span class="line">app.add_route(SimpleAsyncView.as_view(), &apos;/async&apos;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(host=&quot;0.0.0.0&quot;, port=8000, debug=True)</span><br></pre></td></tr></table></figure>

<h3 id="URL重定向"><a href="#URL重定向" class="headerlink" title="URL重定向"></a>URL重定向</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from sanic import Sanic</span><br><span class="line">from sanic import response</span><br><span class="line"></span><br><span class="line">app = Sanic(__name__)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">def handle_request(request):</span><br><span class="line">    return response.redirect(&apos;/redirect&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&apos;/redirect&apos;)</span><br><span class="line">async def test(request):</span><br><span class="line">    return response.json(&#123;&quot;Redirected&quot;: True&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(host=&quot;0.0.0.0&quot;, port=8000)</span><br></pre></td></tr></table></figure>

<h3 id="命名URL重定向"><a href="#命名URL重定向" class="headerlink" title="命名URL重定向"></a>命名URL重定向</h3><p><code>Sanic</code> 提供一种简单易用的方法，通过名为 <code>url_for</code> 它采用唯一的URL名称作为参数，并返回为其分配的实际路由。这将有助于简化在应用程序的不同部分之间重定向用户所需的工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from sanic import Sanic</span><br><span class="line">from sanic import response</span><br><span class="line"></span><br><span class="line">app = Sanic(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">async def index(request):</span><br><span class="line">    # generate a URL for the endpoint `post_handler`</span><br><span class="line">    url = app.url_for(&apos;post_handler&apos;, post_id=5)</span><br><span class="line">    # the URL is `/posts/5`, redirect to it</span><br><span class="line">    return response.redirect(url)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&apos;/posts/&lt;post_id&gt;&apos;)</span><br><span class="line">async def post_handler(request, post_id):</span><br><span class="line">    return response.text(&apos;Post - &#123;&#125;&apos;.format(post_id))</span><br><span class="line">    </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(host=&quot;0.0.0.0&quot;, port=8000, debug=True)</span><br></pre></td></tr></table></figure>

<h3 id="蓝图"><a href="#蓝图" class="headerlink" title="蓝图"></a>蓝图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Sanic` provides an amazing feature to group your APIs and routes under a logical collection that can easily be imported and plugged into any of your sanic application and it&apos;s called `blueprints</span><br><span class="line">from sanic import Blueprint, Sanic</span><br><span class="line">from sanic.response import file, json</span><br><span class="line"></span><br><span class="line">app = Sanic(__name__)</span><br><span class="line">blueprint = Blueprint(&apos;name&apos;, url_prefix=&apos;/my_blueprint&apos;)</span><br><span class="line">blueprint2 = Blueprint(&apos;name2&apos;, url_prefix=&apos;/my_blueprint2&apos;)</span><br><span class="line">blueprint3 = Blueprint(&apos;name3&apos;, url_prefix=&apos;/my_blueprint3&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@blueprint.route(&apos;/foo&apos;)</span><br><span class="line">async def foo(request):</span><br><span class="line">    return json(&#123;&apos;msg&apos;: &apos;hi from blueprint&apos;&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@blueprint2.route(&apos;/foo&apos;)</span><br><span class="line">async def foo2(request):</span><br><span class="line">    return json(&#123;&apos;msg&apos;: &apos;hi from blueprint2&apos;&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@blueprint3.route(&apos;/foo&apos;)</span><br><span class="line">async def index(request):</span><br><span class="line">    return await file(&apos;websocket.html&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.websocket(&apos;/feed&apos;)</span><br><span class="line">async def foo3(request, ws):</span><br><span class="line">    while True:</span><br><span class="line">        data = &apos;hello!&apos;</span><br><span class="line">        print(&apos;Sending: &apos; + data)</span><br><span class="line">        await ws.send(data)</span><br><span class="line">        data = await ws.recv()</span><br><span class="line">        print(&apos;Received: &apos; + data)</span><br><span class="line"></span><br><span class="line">app.blueprint(blueprint)</span><br><span class="line">app.blueprint(blueprint2)</span><br><span class="line">app.blueprint(blueprint3)</span><br><span class="line"></span><br><span class="line">app.run(host=&quot;0.0.0.0&quot;, port=8000, debug=True)</span><br></pre></td></tr></table></figure>

<h3 id="日志功能增强"><a href="#日志功能增强" class="headerlink" title="日志功能增强"></a>日志功能增强</h3><p>尽管 <code>Sanic</code> 附带了一组日志记录支持，它允许最终用户自定义在应用程序运行时处理日志记录的方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from sanic import Sanic</span><br><span class="line">from sanic import response</span><br><span class="line">import logging</span><br><span class="line"></span><br><span class="line">logging_format = &quot;[%(asctime)s] %(process)d-%(levelname)s &quot;</span><br><span class="line">logging_format += &quot;%(module)s::%(funcName)s():l%(lineno)d: &quot;</span><br><span class="line">logging_format += &quot;%(message)s&quot;</span><br><span class="line"></span><br><span class="line">logging.basicConfig(</span><br><span class="line">    format=logging_format,</span><br><span class="line">    level=logging.DEBUG</span><br><span class="line">)</span><br><span class="line">log = logging.getLogger()</span><br><span class="line"></span><br><span class="line"># Set logger to override default basicConfig</span><br><span class="line">sanic = Sanic()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@sanic.route(&quot;/&quot;)</span><br><span class="line">def test(request):</span><br><span class="line">    log.info(&quot;received request; responding with &apos;hey&apos;&quot;)</span><br><span class="line">    return response.text(&quot;hey&quot;)</span><br><span class="line"></span><br><span class="line">sanic.run(host=&quot;0.0.0.0&quot;, port=8000)</span><br></pre></td></tr></table></figure>

<p>下面的示例提供了一个示例代码，演示了 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic.middleware" target="_blank" rel="noopener"><code>sanic.app.Sanic.middleware()</code></a> 为了提供一种机制，为每个传入请求分配一个唯一的请求ID，并通过 <a href="https://github.com/Skyscanner/aiotask-context" target="_blank" rel="noopener">aiotask-context</a> .</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">&apos;&apos;&apos;</span><br><span class="line">Based on example from https://github.com/Skyscanner/aiotask-context</span><br><span class="line">and `examples/&#123;override_logging,run_async&#125;.py`.</span><br><span class="line"></span><br><span class="line">Needs https://github.com/Skyscanner/aiotask-context/tree/52efbc21e2e1def2d52abb9a8e951f3ce5e6f690 or newer</span><br><span class="line"></span><br><span class="line">$ pip install git+https://github.com/Skyscanner/aiotask-context.git</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">import asyncio</span><br><span class="line">import uuid</span><br><span class="line">import logging</span><br><span class="line">from signal import signal, SIGINT</span><br><span class="line"></span><br><span class="line">from sanic import Sanic</span><br><span class="line">from sanic import response</span><br><span class="line"></span><br><span class="line">import uvloop</span><br><span class="line">import aiotask_context as context</span><br><span class="line"></span><br><span class="line">log = logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class RequestIdFilter(logging.Filter):</span><br><span class="line">    def filter(self, record):</span><br><span class="line">        record.request_id = context.get(&apos;X-Request-ID&apos;)</span><br><span class="line">        return True</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LOG_SETTINGS = &#123;</span><br><span class="line">    &apos;version&apos;: 1,</span><br><span class="line">    &apos;disable_existing_loggers&apos;: False,</span><br><span class="line">    &apos;handlers&apos;: &#123;</span><br><span class="line">        &apos;console&apos;: &#123;</span><br><span class="line">            &apos;class&apos;: &apos;logging.StreamHandler&apos;,</span><br><span class="line">            &apos;level&apos;: &apos;DEBUG&apos;,</span><br><span class="line">            &apos;formatter&apos;: &apos;default&apos;,</span><br><span class="line">            &apos;filters&apos;: [&apos;requestid&apos;],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;filters&apos;: &#123;</span><br><span class="line">        &apos;requestid&apos;: &#123;</span><br><span class="line">            &apos;()&apos;: RequestIdFilter,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;formatters&apos;: &#123;</span><br><span class="line">        &apos;default&apos;: &#123;</span><br><span class="line">            &apos;format&apos;: &apos;%(asctime)s %(levelname)s %(name)s:%(lineno)d %(request_id)s | %(message)s&apos;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;loggers&apos;: &#123;</span><br><span class="line">        &apos;&apos;: &#123;</span><br><span class="line">            &apos;level&apos;: &apos;DEBUG&apos;,</span><br><span class="line">            &apos;handlers&apos;: [&apos;console&apos;],</span><br><span class="line">            &apos;propagate&apos;: True</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Sanic(__name__, log_config=LOG_SETTINGS)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.middleware(&apos;request&apos;)</span><br><span class="line">async def set_request_id(request):</span><br><span class="line">    request_id = request.headers.get(&apos;X-Request-ID&apos;) or str(uuid.uuid4())</span><br><span class="line">    context.set(&quot;X-Request-ID&quot;, request_id)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&quot;)</span><br><span class="line">async def test(request):</span><br><span class="line">    log.debug(&apos;X-Request-ID: %s&apos;, context.get(&apos;X-Request-ID&apos;))</span><br><span class="line">    log.info(&apos;Hello from test!&apos;)</span><br><span class="line">    return response.json(&#123;&quot;test&quot;: True&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    asyncio.set_event_loop(uvloop.new_event_loop())</span><br><span class="line">    server = app.create_server(host=&quot;0.0.0.0&quot;, port=8000, return_asyncio_server=True)</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.set_task_factory(context.task_factory)</span><br><span class="line">    task = asyncio.ensure_future(server)</span><br><span class="line">    try:</span><br><span class="line">        loop.run_forever()</span><br><span class="line">    except:</span><br><span class="line">        loop.stop()</span><br></pre></td></tr></table></figure>

<h3 id="Sanic流支持"><a href="#Sanic流支持" class="headerlink" title="Sanic流支持"></a>Sanic流支持</h3><p><code>Sanic</code> 框架附带了对大文件流式处理的内置支持，下面的代码解释了设置 <code>Sanic</code> 支持流媒体的应用程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">from sanic import Sanic</span><br><span class="line">from sanic.views import CompositionView</span><br><span class="line">from sanic.views import HTTPMethodView</span><br><span class="line">from sanic.views import stream as stream_decorator</span><br><span class="line">from sanic.blueprints import Blueprint</span><br><span class="line">from sanic.response import stream, text</span><br><span class="line"></span><br><span class="line">bp = Blueprint(&apos;blueprint_request_stream&apos;)</span><br><span class="line">app = Sanic(&apos;request_stream&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SimpleView(HTTPMethodView):</span><br><span class="line"></span><br><span class="line">    @stream_decorator</span><br><span class="line">    async def post(self, request):</span><br><span class="line">        result = &apos;&apos;</span><br><span class="line">        while True:</span><br><span class="line">            body = await request.stream.get()</span><br><span class="line">            if body is None:</span><br><span class="line">                break</span><br><span class="line">            result += body.decode(&apos;utf-8&apos;)</span><br><span class="line">        return text(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.post(&apos;/stream&apos;, stream=True)</span><br><span class="line">async def handler(request):</span><br><span class="line">    async def streaming(response):</span><br><span class="line">        while True:</span><br><span class="line">            body = await request.stream.get()</span><br><span class="line">            if body is None:</span><br><span class="line">                break</span><br><span class="line">            body = body.decode(&apos;utf-8&apos;).replace(&apos;1&apos;, &apos;A&apos;)</span><br><span class="line">            await response.write(body)</span><br><span class="line">    return stream(streaming)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@bp.put(&apos;/bp_stream&apos;, stream=True)</span><br><span class="line">async def bp_handler(request):</span><br><span class="line">    result = &apos;&apos;</span><br><span class="line">    while True:</span><br><span class="line">        body = await request.stream.get()</span><br><span class="line">        if body is None:</span><br><span class="line">            break</span><br><span class="line">        result += body.decode(&apos;utf-8&apos;).replace(&apos;1&apos;, &apos;A&apos;)</span><br><span class="line">    return text(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async def post_handler(request):</span><br><span class="line">    result = &apos;&apos;</span><br><span class="line">    while True:</span><br><span class="line">        body = await request.stream.get()</span><br><span class="line">        if body is None:</span><br><span class="line">            break</span><br><span class="line">        result += body.decode(&apos;utf-8&apos;)</span><br><span class="line">    return text(result)</span><br><span class="line"></span><br><span class="line">app.blueprint(bp)</span><br><span class="line">app.add_route(SimpleView.as_view(), &apos;/method_view&apos;)</span><br><span class="line">view = CompositionView()</span><br><span class="line">view.add([&apos;POST&apos;], post_handler, stream=True)</span><br><span class="line">app.add_route(view, &apos;/composition_view&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(host=&apos;0.0.0.0&apos;, port=8000)</span><br></pre></td></tr></table></figure>

<p>示例客户端应用程序，按客户端代码显示流式应用程序的用法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line"># Warning: This is a heavy process.</span><br><span class="line"></span><br><span class="line">data = &quot;&quot;</span><br><span class="line">for i in range(1, 250000):</span><br><span class="line">    data += str(i)</span><br><span class="line"></span><br><span class="line">r = requests.post(&apos;http://0.0.0.0:8000/stream&apos;, data=data)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure>

<h3 id="SANIC并发支持"><a href="#SANIC并发支持" class="headerlink" title="SANIC并发支持"></a>SANIC并发支持</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Sanic` supports the ability to start an app with multiple worker support. However, it&apos;s important to be able to limit the concurrency per process/loop in order to ensure an efficient execution. The following section of the code provides a brief example of how to limit the concurrency with the help of `asyncio.Semaphore</span><br><span class="line">from sanic import Sanic</span><br><span class="line">from sanic.response import json</span><br><span class="line"></span><br><span class="line">import asyncio</span><br><span class="line">import aiohttp</span><br><span class="line"></span><br><span class="line">app = Sanic(__name__)</span><br><span class="line"></span><br><span class="line">sem = None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.listener(&apos;before_server_start&apos;)</span><br><span class="line">def init(sanic, loop):</span><br><span class="line">    global sem</span><br><span class="line">    concurrency_per_worker = 4</span><br><span class="line">    sem = asyncio.Semaphore(concurrency_per_worker, loop=loop)</span><br><span class="line"></span><br><span class="line">async def bounded_fetch(session, url):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Use session object to perform &apos;get&apos; request on url</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    async with sem, session.get(url) as response:</span><br><span class="line">        return await response.json()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&quot;)</span><br><span class="line">async def test(request):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Download and serve example JSON</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    url = &quot;https://api.github.com/repos/channelcat/sanic&quot;</span><br><span class="line"></span><br><span class="line">    async with aiohttp.ClientSession() as session:</span><br><span class="line">        response = await bounded_fetch(session, url)</span><br><span class="line">        return json(response)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.run(host=&quot;0.0.0.0&quot;, port=8000, workers=2)</span><br></pre></td></tr></table></figure>

<h3 id="通过Docker的Sanic部署"><a href="#通过Docker的Sanic部署" class="headerlink" title="通过Docker的Sanic部署"></a>通过Docker的Sanic部署</h3><p>部署一个 <code>sanic</code> 应用程序通过 <code>docker</code> 和 <code>docker-compose</code> 是一个容易实现的任务，下面的示例提供了示例的部署 <code>simple_server.py</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.5</span><br><span class="line">MAINTAINER Channel Cat &lt;channelcat@gmail.com&gt;</span><br><span class="line"></span><br><span class="line">ADD . /code</span><br><span class="line">RUN pip3 install git+https://github.com/channelcat/sanic</span><br><span class="line"></span><br><span class="line">EXPOSE 8000</span><br><span class="line"></span><br><span class="line">WORKDIR /code</span><br><span class="line"></span><br><span class="line">CMD [&quot;python&quot;, &quot;simple_server.py&quot;]</span><br><span class="line">version: &apos;2&apos;</span><br><span class="line">services:</span><br><span class="line">  sanic:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8000:8000&quot;</span><br></pre></td></tr></table></figure>

<h3 id="监控和错误处理"><a href="#监控和错误处理" class="headerlink" title="监控和错误处理"></a>监控和错误处理</h3><p><code>Sanic</code> 通过以下方式提供全局异常处理程序的可扩展裸最小实现： <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.handlers.ErrorHandler" target="_blank" rel="noopener"><code>sanic.handlers.ErrorHandler</code></a> . 此示例演示如何扩展它以启用某些自定义行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">Example intercepting uncaught exceptions using Sanic&apos;s error handler framework.</span><br><span class="line">This may be useful for developers wishing to use Sentry, Airbrake, etc.</span><br><span class="line">or a custom system to log and monitor unexpected errors in production.</span><br><span class="line">First we create our own class inheriting from Handler in sanic.exceptions,</span><br><span class="line">and pass in an instance of it when we create our Sanic instance. Inside this</span><br><span class="line">class&apos; default handler, we can do anything including sending exceptions to</span><br><span class="line">an external service.</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">from sanic.handlers import ErrorHandler</span><br><span class="line">from sanic.exceptions import SanicException</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Imports and code relevant for our CustomHandler class</span><br><span class="line">(Ordinarily this would be in a separate file)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class CustomHandler(ErrorHandler):</span><br><span class="line"></span><br><span class="line">    def default(self, request, exception):</span><br><span class="line">        # Here, we have access to the exception object</span><br><span class="line">        # and can do anything with it (log, send to external service, etc)</span><br><span class="line"></span><br><span class="line">        # Some exceptions are trivial and built into Sanic (404s, etc)</span><br><span class="line">        if not isinstance(exception, SanicException):</span><br><span class="line">            print(exception)</span><br><span class="line"></span><br><span class="line">        # Then, we must finish handling the exception by returning</span><br><span class="line">        # our response to the client</span><br><span class="line">        # For this we can just call the super class&apos; default handler</span><br><span class="line">        return super().default(request, exception)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">This is an ordinary Sanic server, with the exception that we set the</span><br><span class="line">server&apos;s error_handler to an instance of our CustomHandler</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">from sanic import Sanic</span><br><span class="line"></span><br><span class="line">app = Sanic(__name__)</span><br><span class="line"></span><br><span class="line">handler = CustomHandler()</span><br><span class="line">app.error_handler = handler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&quot;)</span><br><span class="line">async def test(request):</span><br><span class="line">    # Here, something occurs which causes an unexpected exception</span><br><span class="line">    # This exception will flow to our custom handler.</span><br><span class="line">    raise SanicException(&apos;You Broke It!&apos;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(host=&quot;0.0.0.0&quot;, port=8000, debug=True)</span><br></pre></td></tr></table></figure>

<h3 id="使用外部服务提供商进行监控"><a href="#使用外部服务提供商进行监控" class="headerlink" title="使用外部服务提供商进行监控"></a>使用外部服务提供商进行监控</h3><ul>
<li><a href="https://logdna.com/" target="_blank" rel="noopener">LogDNA</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">import socket</span><br><span class="line">from os import getenv</span><br><span class="line">from platform import node</span><br><span class="line">from uuid import getnode as get_mac</span><br><span class="line"></span><br><span class="line">from logdna import LogDNAHandler</span><br><span class="line"></span><br><span class="line">from sanic import Sanic</span><br><span class="line">from sanic.response import json</span><br><span class="line">from sanic.request import Request</span><br><span class="line"></span><br><span class="line">log = logging.getLogger(&apos;logdna&apos;)</span><br><span class="line">log.setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_my_ip_address(remote_server=&quot;google.com&quot;):</span><br><span class="line">    with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:</span><br><span class="line">        s.connect((remote_server, 80))</span><br><span class="line">        return s.getsockname()[0]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_mac_address():</span><br><span class="line">    h = iter(hex(get_mac())[2:].zfill(12))</span><br><span class="line">    return &quot;:&quot;.join(i + next(h) for i in h)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">logdna_options = &#123;</span><br><span class="line">    &quot;app&quot;: __name__,</span><br><span class="line">    &quot;index_meta&quot;: True,</span><br><span class="line">    &quot;hostname&quot;: node(),</span><br><span class="line">    &quot;ip&quot;: get_my_ip_address(),</span><br><span class="line">    &quot;mac&quot;: get_mac_address()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logdna_handler = LogDNAHandler(getenv(&quot;LOGDNA_API_KEY&quot;), options=logdna_options)</span><br><span class="line"></span><br><span class="line">logdna = logging.getLogger(__name__)</span><br><span class="line">logdna.setLevel(logging.INFO)</span><br><span class="line">logdna.addHandler(logdna_handler)</span><br><span class="line"></span><br><span class="line">app = Sanic(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.middleware</span><br><span class="line">def log_request(request: Request):</span><br><span class="line">    logdna.info(&quot;I was Here with a new Request to URL: &#123;&#125;&quot;.format(request.url))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&quot;)</span><br><span class="line">def default(request):</span><br><span class="line">    return json(&#123;</span><br><span class="line">        &quot;response&quot;: &quot;I was here&quot;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app.run(</span><br><span class="line">        host=&quot;0.0.0.0&quot;,</span><br><span class="line">        port=getenv(&quot;PORT&quot;, 8080)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://raygun.com/" target="_blank" rel="noopener">RayGun</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">from os import getenv</span><br><span class="line"></span><br><span class="line">from raygun4py.raygunprovider import RaygunSender</span><br><span class="line"></span><br><span class="line">from sanic import Sanic</span><br><span class="line">from sanic.exceptions import SanicException</span><br><span class="line">from sanic.handlers import ErrorHandler</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class RaygunExceptionReporter(ErrorHandler):</span><br><span class="line"></span><br><span class="line">    def __init__(self, raygun_api_key=None):</span><br><span class="line">        super().__init__()</span><br><span class="line">        if raygun_api_key is None:</span><br><span class="line">            raygun_api_key = getenv(&quot;RAYGUN_API_KEY&quot;)</span><br><span class="line"></span><br><span class="line">        self.sender = RaygunSender(raygun_api_key)</span><br><span class="line"></span><br><span class="line">    def default(self, request, exception):</span><br><span class="line">        self.sender.send_exception(exception=exception)</span><br><span class="line">        return super().default(request, exception)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">raygun_error_reporter = RaygunExceptionReporter()</span><br><span class="line">app = Sanic(__name__, error_handler=raygun_error_reporter)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&quot;/raise&quot;)</span><br><span class="line">async def test(request):</span><br><span class="line">    raise SanicException(&apos;You Broke It!&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(</span><br><span class="line">        host=&quot;0.0.0.0&quot;,</span><br><span class="line">        port=getenv(&quot;PORT&quot;, 8080)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://rollbar.com/" target="_blank" rel="noopener">Rollbar</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import rollbar</span><br><span class="line"></span><br><span class="line">from sanic.handlers import ErrorHandler</span><br><span class="line">from sanic import Sanic</span><br><span class="line">from sanic.exceptions import SanicException</span><br><span class="line">from os import getenv</span><br><span class="line"></span><br><span class="line">rollbar.init(getenv(&quot;ROLLBAR_API_KEY&quot;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class RollbarExceptionHandler(ErrorHandler):</span><br><span class="line"></span><br><span class="line">    def default(self, request, exception):</span><br><span class="line">        rollbar.report_message(str(exception))</span><br><span class="line">        return super().default(request, exception)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Sanic(__name__, error_handler=RollbarExceptionHandler())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&quot;/raise&quot;)</span><br><span class="line">def create_error(request):</span><br><span class="line">    raise SanicException(&quot;I was here and I don&apos;t like where I am&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app.run(</span><br><span class="line">        host=&quot;0.0.0.0&quot;,</span><br><span class="line">        port=getenv(&quot;PORT&quot;, 8080)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="http://sentry.io/" target="_blank" rel="noopener">Sentry</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">from os import getenv</span><br><span class="line"></span><br><span class="line">from sentry_sdk import init as sentry_init</span><br><span class="line">from sentry_sdk.integrations.sanic import SanicIntegration</span><br><span class="line"></span><br><span class="line">from sanic import Sanic</span><br><span class="line">from sanic.response import json</span><br><span class="line"></span><br><span class="line">sentry_init(</span><br><span class="line">    dsn=getenv(&quot;SENTRY_DSN&quot;),</span><br><span class="line">    integrations=[SanicIntegration()],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">app = Sanic(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># noinspection PyUnusedLocal</span><br><span class="line">@app.route(&quot;/working&quot;)</span><br><span class="line">async def working_path(request):</span><br><span class="line">    return json(&#123;</span><br><span class="line">        &quot;response&quot;: &quot;Working API Response&quot;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># noinspection PyUnusedLocal</span><br><span class="line">@app.route(&quot;/raise-error&quot;)</span><br><span class="line">async def raise_error(request):</span><br><span class="line">    raise Exception(&quot;Testing Sentry Integration&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(</span><br><span class="line">        host=&quot;0.0.0.0&quot;,</span><br><span class="line">        port=getenv(&quot;PORT&quot;, 8080)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>下面的示例代码显示了一个简单的基于装饰器的身份验证和授权机制，可以设置该机制来保护 <code>sanic</code> API端点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">from sanic import Sanic</span><br><span class="line">from functools import wraps</span><br><span class="line">from sanic.response import json</span><br><span class="line"></span><br><span class="line">app = Sanic()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def check_request_for_authorization_status(request):</span><br><span class="line">    # Note: Define your check, for instance cookie, session.</span><br><span class="line">    flag = True</span><br><span class="line">    return flag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def authorized():</span><br><span class="line">    def decorator(f):</span><br><span class="line">        @wraps(f)</span><br><span class="line">        async def decorated_function(request, *args, **kwargs):</span><br><span class="line">            # run some method that checks the request</span><br><span class="line">            # for the client&apos;s authorization status</span><br><span class="line">            is_authorized = check_request_for_authorization_status(request)</span><br><span class="line"></span><br><span class="line">            if is_authorized:</span><br><span class="line">                # the user is authorized.</span><br><span class="line">                # run the handler method and return the response</span><br><span class="line">                response = await f(request, *args, **kwargs)</span><br><span class="line">                return response</span><br><span class="line">            else:</span><br><span class="line">                # the user is not authorized.</span><br><span class="line">                return json(&#123;&apos;status&apos;: &apos;not_authorized&apos;&#125;, 403)</span><br><span class="line">        return decorated_function</span><br><span class="line">    return decorator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&quot;)</span><br><span class="line">@authorized()</span><br><span class="line">async def test(request):</span><br><span class="line">    return json(&#123;&apos;status&apos;: &apos;authorized&apos;&#125;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app.run(host=&quot;0.0.0.0&quot;, port=8000)</span><br></pre></td></tr></table></figure>

<h3 id="SANIC网络套接字"><a href="#SANIC网络套接字" class="headerlink" title="SANIC网络套接字"></a>SANIC网络套接字</h3><p><code>Sanic</code> 提供轻松添加路线并将其映射到 <code>websocket</code> 处理程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;WebSocket demo&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            var ws = new WebSocket(&apos;ws://&apos; + document.domain + &apos;:&apos; + location.port + &apos;/feed&apos;),</span><br><span class="line">                messages = document.createElement(&apos;ul&apos;);</span><br><span class="line">            ws.onmessage = function (event) &#123;</span><br><span class="line">                var messages = document.getElementsByTagName(&apos;ul&apos;)[0],</span><br><span class="line">                    message = document.createElement(&apos;li&apos;),</span><br><span class="line">                    content = document.createTextNode(&apos;Received: &apos; + event.data);</span><br><span class="line">                message.appendChild(content);</span><br><span class="line">                messages.appendChild(message);</span><br><span class="line">            &#125;;</span><br><span class="line">            document.body.appendChild(messages);</span><br><span class="line">            window.setInterval(function() &#123;</span><br><span class="line">                data = &apos;bye!&apos;</span><br><span class="line">                ws.send(data);</span><br><span class="line">                var messages = document.getElementsByTagName(&apos;ul&apos;)[0],</span><br><span class="line">                    message = document.createElement(&apos;li&apos;),</span><br><span class="line">                    content = document.createTextNode(&apos;Sent: &apos; + data);</span><br><span class="line">                message.appendChild(content);</span><br><span class="line">                messages.appendChild(message);</span><br><span class="line">            &#125;, 1000);</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">from sanic import Sanic</span><br><span class="line">from sanic.response import file</span><br><span class="line"></span><br><span class="line">app = Sanic(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&apos;/&apos;)</span><br><span class="line">async def index(request):</span><br><span class="line">    return await file(&apos;websocket.html&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.websocket(&apos;/feed&apos;)</span><br><span class="line">async def feed(request, ws):</span><br><span class="line">    while True:</span><br><span class="line">        data = &apos;hello!&apos;</span><br><span class="line">        print(&apos;Sending: &apos; + data)</span><br><span class="line">        await ws.send(data)</span><br><span class="line">        data = await ws.recv()</span><br><span class="line">        print(&apos;Received: &apos; + data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(host=&quot;0.0.0.0&quot;, port=8000, debug=True)</span><br></pre></td></tr></table></figure>

<h3 id="主机托管"><a href="#主机托管" class="headerlink" title="主机托管"></a>主机托管</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">from sanic import response</span><br><span class="line">from sanic import Sanic</span><br><span class="line">from sanic.blueprints import Blueprint</span><br><span class="line"></span><br><span class="line"># Usage</span><br><span class="line"># curl -H &quot;Host: example.com&quot; localhost:8000</span><br><span class="line"># curl -H &quot;Host: sub.example.com&quot; localhost:8000</span><br><span class="line"># curl -H &quot;Host: bp.example.com&quot; localhost:8000/question</span><br><span class="line"># curl -H &quot;Host: bp.example.com&quot; localhost:8000/answer</span><br><span class="line"></span><br><span class="line">app = Sanic()</span><br><span class="line">bp = Blueprint(&quot;bp&quot;, host=&quot;bp.example.com&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&apos;/&apos;, host=[&quot;example.com&quot;,</span><br><span class="line">                      &quot;somethingelse.com&quot;,</span><br><span class="line">                      &quot;therestofyourdomains.com&quot;])</span><br><span class="line">async def hello(request):</span><br><span class="line">    return response.text(&quot;Some defaults&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&apos;/&apos;, host=&quot;sub.example.com&quot;)</span><br><span class="line">async def hello(request):</span><br><span class="line">    return response.text(&quot;42&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@bp.route(&quot;/question&quot;)</span><br><span class="line">async def hello(request):</span><br><span class="line">    return response.text(&quot;What is the meaning of life?&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@bp.route(&quot;/answer&quot;)</span><br><span class="line">async def hello(request):</span><br><span class="line">    return response.text(&quot;42&quot;)</span><br><span class="line"></span><br><span class="line">app.blueprint(bp)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    app.run(host=&quot;0.0.0.0&quot;, port=8000)</span><br></pre></td></tr></table></figure>

<h3 id="具有并行测试运行支持的单元测试"><a href="#具有并行测试运行支持的单元测试" class="headerlink" title="具有并行测试运行支持的单元测试"></a>具有并行测试运行支持的单元测试</h3><p>下面的示例向您展示了如何启动和运行单元测试 <code>sanic</code> 提供并行测试执行支持的应用程序 <code>pytest-xdist</code> 插件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;pytest-xdist example for sanic server</span><br><span class="line"></span><br><span class="line">Install testing tools:</span><br><span class="line"></span><br><span class="line">    $ pip install pytest pytest-xdist</span><br><span class="line"></span><br><span class="line">Run with xdist params:</span><br><span class="line"></span><br><span class="line">    $ pytest examples/pytest_xdist.py -n 8  # 8 workers</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import re</span><br><span class="line">from sanic import Sanic</span><br><span class="line">from sanic.response import text</span><br><span class="line">from sanic.testing import PORT as PORT_BASE, SanicTestClient</span><br><span class="line">import pytest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@pytest.fixture(scope=&quot;session&quot;)</span><br><span class="line">def test_port(worker_id):</span><br><span class="line">    m = re.search(r&apos;[0-9]+&apos;, worker_id)</span><br><span class="line">    if m:</span><br><span class="line">        num_id = m.group(0)</span><br><span class="line">    else:</span><br><span class="line">        num_id = 0</span><br><span class="line">    port = PORT_BASE + int(num_id)</span><br><span class="line">    return port</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@pytest.fixture(scope=&quot;session&quot;)</span><br><span class="line">def app():</span><br><span class="line">    app = Sanic()</span><br><span class="line"></span><br><span class="line">    @app.route(&apos;/&apos;)</span><br><span class="line">    async def index(request):</span><br><span class="line">        return text(&apos;OK&apos;)</span><br><span class="line"></span><br><span class="line">    return app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@pytest.fixture(scope=&quot;session&quot;)</span><br><span class="line">def client(app, test_port):</span><br><span class="line">    return SanicTestClient(app, test_port)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@pytest.mark.parametrize(&apos;run_id&apos;, range(100))</span><br><span class="line">def test_index(client, run_id):</span><br><span class="line">    request, response = client._sanic_endpoint_test(&apos;get&apos;, &apos;/&apos;)</span><br><span class="line">    assert response.status == 200</span><br><span class="line">    assert response.text == &apos;OK&apos;</span><br></pre></td></tr></table></figure>

<h3 id="修改请求对象"><a href="#修改请求对象" class="headerlink" title="修改请求对象"></a>修改请求对象</h3><p>这个 <code>request</code> 中的对象 <code>Sanic</code> 是一种 <code>dict</code> 对象，这意味着 <code>request</code> 对象可以作为常规对象进行操作 <code>dict</code> 对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sanic <span class="keyword">import</span> Sanic</span><br><span class="line"><span class="keyword">from</span> sanic.response <span class="keyword">import</span> text</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line">app = Sanic()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.middleware('request')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">append_request</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment"># Add new key with random value</span></span><br><span class="line">    request[<span class="string">'num'</span>] = randint(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get('/pop')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pop_handler</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment"># Pop key from request object</span></span><br><span class="line">    num = request.pop(<span class="string">'num'</span>)</span><br><span class="line">    <span class="keyword">return</span> text(num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get('/key_exist')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">key_exist_handler</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment"># Check the key is exist or not</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'num'</span> <span class="keyword">in</span> request:</span><br><span class="line">        <span class="keyword">return</span> text(<span class="string">'num exist in request'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> text(<span class="string">'num does not exist in reqeust'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.run(host=<span class="string">"0.0.0.0"</span>, port=<span class="number">8000</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h1 id="API引用"><a href="#API引用" class="headerlink" title="API引用"></a>API引用</h1><h2 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h2><h2 id="sanic-app-模块"><a href="#sanic-app-模块" class="headerlink" title="sanic.app 模块"></a>sanic.app 模块</h2><ul>
<li><p><em>class<em><code>sanic.app.``Sanic</code>(</em>name=None</em>, <em>router=None</em>, <em>error_handler=None</em>, <em>load_env=True</em>, <em>request_class=None</em>, <em>strict_slashes=False</em>, <em>log_config=None</em>, <em>configure_logging=True</em>)</p>
<p>基类：<code>object``add_route</code>(<em>handler</em>, <em>uri</em>, <em>methods=frozenset({‘GET’})</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>version=None</em>, <em>name=None</em>, <em>stream=False</em>)将类实例或函数注册为应用程序URL路由的处理程序的帮助器方法。参数<strong>handler</strong> – 函数或类实例<strong>uri</strong> – URL路径<strong>methods</strong> – 允许的方法列表或元组，如果使用httpmethodview，则会重写这些方法<strong>host</strong> –<strong>strict_slashes</strong> –<strong>version</strong> –<strong>name</strong> – URL的用户定义路由名称<strong>stream</strong> – 布尔值，指定处理程序是否为流处理程序返回函数或类实例<code>add_task</code>(<em>task</em>)在循环开始后，安排任务稍后运行。与asyncio.secure-future不同的是，它也不会返回未来，实际的secure-future调用会延迟到服务器启动之前。参数<strong>task</strong> – 未来、古鲁特或等待<code>add_websocket_route</code>(<em>handler</em>, <em>uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>subprotocols=None</em>, <em>name=None</em>)将函数注册为WebSocket路由的帮助器方法。参数<strong>handler</strong> – 可以处理WebSocket请求的类的可调用函数或实例<strong>host</strong> – 主机IP或FQDN详细信息<strong>uri</strong> – 将映射到WebSocket处理程序的URL路径<strong>strict_slashes</strong> – 如果API端点需要以“/”终止或不终止<strong>subprotocols</strong> – 用于WebSocket握手的子协议<strong>name</strong> – 为该URL分配的唯一名称，以便它可以与 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic.url_for" target="_blank" rel="noopener"><code>url_for()</code></a>返回反对者装饰者 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic.websocket" target="_blank" rel="noopener"><code>websocket()</code></a><em>property<em><code>asgi_client``blueprint</code>(</em>blueprint</em>, <strong><em>options</em>)在应用程序上注册蓝图。参数</strong>blueprint<em>* – 蓝图对象或其（列表、元组）<strong>options</strong> – 带蓝图默认值的选项字典返回没有什么<code>converted_response_type</code>(*response</em>)未提供实现。<code>delete</code>(<em>uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>version=None</em>, <em>name=None</em>)在下添加API URL <strong>DELETE</strong> <em>HTTP</em> 方法参数<strong>uri</strong> – 要标记到的URL <strong>DELETE</strong> 方法 <em>HTTP<strong>*host</strong> – 要使用的服务的主机IP或FQDN<strong>strict_slashes</strong> – 指导 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic" target="_blank" rel="noopener"><code>Sanic</code></a> 检查请求URL是否需要使用 <em>/**</em>version** – API版本<strong>name</strong> – 可用于标识路由的唯一名称返回具有 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic.route" target="_blank" rel="noopener"><code>route()</code></a> 方法 的对象装饰器<code>enable_websocket</code>(*enable=True</em>)启用或禁用对WebSocket的支持。如果将WebSocket路由添加到应用程序，则会自动启用WebSocket。<code>exception</code>(<strong>exceptions*)修饰要注册为异常处理程序的函数参数</strong>exceptions<em>* – 例外返回装饰功能<code>get</code>(*uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>version=None</em>, <em>name=None</em>)在下添加API URL <strong>GET</strong> <em>HTTP</em> 方法参数<strong>uri</strong> – 要标记到的URL <strong>GET</strong> 方法 <em>HTTP<strong>*host</strong> – 要使用的服务的主机IP或FQDN<strong>strict_slashes</strong> – 指导 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic" target="_blank" rel="noopener"><code>Sanic</code></a> 检查请求URL是否需要使用 <em>/**</em>version** – API版本<strong>name</strong> – 可用于标识路由的唯一名称返回具有 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic.route" target="_blank" rel="noopener"><code>route()</code></a> 方法 的对象装饰器<code>head</code>(*uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>version=None</em>, <em>name=None</em>)<code>listener</code>(<em>event</em>)从修饰函数创建侦听器。参数<strong>event</strong> – 要收听的事件<em>property<em><code>loop</code>与asyncio.get_event_loop（）同义。仅在使用时支持 app.run 方法。<code>middleware</code>(</em>middleware_or_request</em>)装饰和注册在请求之前调用的中间件。可以调用为 <em>@app.middleware</em> 或 <em>@应用中间件（请求）<em>Param中间件请求：用于标识正在注册的中间件类型的可选参数。<code>options</code>(</em>uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>version=None</em>, <em>name=None</em>)在下添加API URL <strong>OPTIONS</strong> <em>HTTP</em> 方法参数<strong>uri</strong> – 要标记到的URL <strong>OPTIONS</strong> 方法 <em>HTTP<strong>*host</strong> – 要使用的服务的主机IP或FQDN<strong>strict_slashes</strong> – 指导 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic" target="_blank" rel="noopener"><code>Sanic</code></a> 检查请求URL是否需要使用 <em>/**</em>version** – API版本<strong>name</strong> – 可用于标识路由的唯一名称返回具有 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic.route" target="_blank" rel="noopener"><code>route()</code></a> 方法 的对象装饰器<code>patch</code>(*uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>stream=False</em>, <em>version=None</em>, <em>name=None</em>)在下添加API URL <strong>PATCH</strong> <em>HTTP</em> 方法参数<strong>uri</strong> – 要标记到的URL <strong>PATCH</strong> 方法 <em>HTTP<strong>*host</strong> – 要使用的服务的主机IP或FQDN<strong>strict_slashes</strong> – 指导 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic" target="_blank" rel="noopener"><code>Sanic</code></a> 检查请求URL是否需要使用 <em>/**</em>version** – API版本<strong>name</strong> – 可用于标识路由的唯一名称返回具有 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic.route" target="_blank" rel="noopener"><code>route()</code></a> 方法 的对象装饰器<code>post</code>(*uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>stream=False</em>, <em>version=None</em>, <em>name=None</em>)在下添加API URL <strong>POST</strong> <em>HTTP</em> 方法参数<strong>uri</strong> – 要标记到的URL <strong>POST</strong> 方法 <em>HTTP<strong>*host</strong> – 要使用的服务的主机IP或FQDN<strong>strict_slashes</strong> – 指导 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic" target="_blank" rel="noopener"><code>Sanic</code></a> 检查请求URL是否需要使用 <em>/**</em>version** – API版本<strong>name</strong> – 可用于标识路由的唯一名称返回具有 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic.route" target="_blank" rel="noopener"><code>route()</code></a> 方法 的对象装饰器<code>put</code>(*uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>stream=False</em>, <em>version=None</em>, <em>name=None</em>)在下添加API URL <strong>PUT</strong> <em>HTTP</em> 方法参数<strong>uri</strong> – 要标记到的URL <strong>PUT</strong> 方法 <em>HTTP<strong>*host</strong> – 要使用的服务的主机IP或FQDN<strong>strict_slashes</strong> – 指导 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic" target="_blank" rel="noopener"><code>Sanic</code></a> 检查请求URL是否需要使用 <em>/**</em>version** – API版本<strong>name</strong> – 可用于标识路由的唯一名称返回具有 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic.route" target="_blank" rel="noopener"><code>route()</code></a> 方法 的对象装饰器<code>register_blueprint</code>(**args</em>, <strong><em>kwargs</em>)为调用 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic.blueprint" target="_blank" rel="noopener"><code>blueprint()</code></a> 方法注解在1.0中被弃用。使用 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic.blueprint" target="_blank" rel="noopener"><code>blueprint()</code></a> 相反。参数</strong>args<em>* – 蓝图对象或其（列表、元组）<strong>kwargs</strong> – 带蓝图默认值的选项字典返回没有<code>register_listener</code>(*listener</em>, <em>event</em>)注册给定事件的侦听器。ARG:listener:callable，即setup_db（app，loop）event：何时注册listener，即’before_server_start’返回：侦听器<code>register_middleware</code>(<em>middleware</em>, <em>attach_to=’request’</em>)注册一个应用程序级中间件，该中间件将附加到此应用程序下注册的所有API URL。此方法由 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic.middleware" target="_blank" rel="noopener"><code>middleware()</code></a> 在应用程序级别提供的装饰器。参数<strong>middleware</strong> – 要附加到中间件的回调方法<strong>attach_to</strong> – 在中间件的生命周期中需要调用中间件的状态 <em>HTTP请求</em> . <strong>请求</strong> -在处理请求之前调用 <strong>响应</strong> -在返回响应之前调用返回装饰器方法<code>remove_route</code>(<em>uri</em>, <em>clean_cache=True</em>, <em>host=None</em>)此方法为应用程序用户提供了一种机制，通过该机制可以从 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic" target="_blank" rel="noopener"><code>Sanic</code></a> 对象警告删除路由在V19.06中已弃用，将从未来版本中删除。参数<strong>uri</strong> – 要从应用程序中删除的URL路径<strong>clean_cache</strong> – 如果需要清理LRU路由缓存，则指示SANIC<strong>host</strong> – 特定于主机的IP地址或FQDN返回没有<code>route</code>(<em>uri</em>, <em>methods=frozenset({‘GET’})</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>stream=False</em>, <em>version=None</em>, <em>name=None</em>)修饰要注册为路由的函数参数<strong>uri</strong> – URL路径<strong>methods</strong> – 允许的方法列表或元组<strong>host</strong> –<strong>strict_slashes</strong> –<strong>stream</strong> –<strong>version</strong> –<strong>name</strong> – URL的用户定义路由名称返回装饰功能<code>run</code>(<em>host: Optional[str] = None</em>, <em>port: Optional[int] = None</em>, <em>debug: bool = False</em>, <em>ssl: Union[dict</em>, <em>ssl.SSLContext</em>, <em>None] = None</em>, <em>sock: Optional[socket.socket] = None</em>, <em>workers: int = 1</em>, <em>protocol: Type[asyncio.protocols.Protocol] = None</em>, <em>backlog: int = 100</em>, <em>stop_event: Any = None</em>, <em>register_sys_signals: bool = True</em>, <em>access_log: Optional[bool] = None</em>, <strong><em>kwargs</em>) → None运行HTTP服务器并监听，直到键盘中断或终端信号。在终端上，在关闭之前排空连接。参数</strong>host<em>* (*str</em>) – 主机地址<strong>port</strong> (<em>int</em>) – 端口到主机上<strong>debug</strong> (<em>bool</em>) – 启用调试输出（减慢服务器速度）<strong>ssl</strong> – sslcontext，或工作进程的ssl加密的证书和密钥的位置：键入ssl:sslcontext或dict:param sock:socket，以便服务器接受来自以下对象的连接：type sock:socket:param workers:在遵守之前接收的进程数：type workers:int:param protocol:asyncio协议的子类：type protocol:type [协议] ：param backlog：系统未接受的连接数。在拒绝新连接之前允许参数<strong>stop_event</strong> (<em>None</em>) – 停止应用程序前要触发的事件-已弃用<strong>register_sys_signals</strong> (<em>bool</em>) – 注册 SIG* 事件<strong>access_log</strong> (<em>bool</em>) – 允许写入访问日志（减慢服务器速度）返回没有什么<code>static</code>(<em>uri</em>, <em>file_or_directory</em>, <em>pattern=’/?.+’</em>, <em>use_modified_since=True</em>, <em>use_content_range=False</em>, <em>stream_large_files=False</em>, <em>name=’static’</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>content_type=None</em>)注册根目录以从中提供文件。输入可以是文件或目录。此方法将使设置 <code>Route</code> 服务静态文件所必需的。参数<strong>uri</strong> – 用于服务静态内容的URL路径<strong>file_or_directory</strong> – 包含静态文件的静态文件/目录的路径<strong>pattern</strong> – 识别有效静态文件的regex模式<strong>use_modified_since</strong> – 如果为真，则发送文件修改时间，如果浏览器与服务器匹配，则返回“未修改”。<strong>use_content_range</strong> – 如果为真，则处理范围请求的头并发送请求的文件部分<strong>stream_large_files</strong> – 如果为真，请使用 <code>StreamingHTTPResponse.file_stream()</code> 处理程序而不是 <code>HTTPResponse.file()</code> 用于发送文件的处理程序。如果这是一个整数，则表示要切换到的阈值大小 <code>StreamingHTTPResponse.file_stream()</code><strong>name</strong> – 用于URL的用户定义名称<strong>host</strong> – 要使用的服务的主机IP或FQDN<strong>strict_slashes</strong> – 指导 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic" target="_blank" rel="noopener"><code>Sanic</code></a> 检查请求URL是否需要使用 <em>/<strong>*content_type</strong> – 标题的用户定义内容类型返回没有<code>stop</code>()这会杀死 Sanic<em>property</em><code>test_client``url_for</code>(*view_name: str</em>, <strong><em>kwargs</em>)基于视图名称和提供的值生成URL。为了构建URL，必须将所有请求参数作为关键字参数提供，并且每个参数必须通过指定参数类型的测试。如果不满足这些条件，a URLBuildError 将被抛出。不是请求参数的关键字参数将包含在输出URL的查询字符串中。参数</strong>view_name<em>* – 引用视图名称的字符串<strong><em>\</em>kwargs</strong> – 用于生成请求参数和查询字符串参数的键和值。返回内置URL产生：URLBuildError<code>websocket</code>(*uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>subprotocols=None</em>, <em>name=None</em>)修饰要注册为WebSocket路由的函数：param uri:url的路径：param host:host ip或fqdn详细信息：param strict_slashes:如果API端点需要终止是否带有“/”参数<strong>subprotocols</strong> – 具有支持的子协议的str的可选列表<strong>name</strong> – 为该URL分配的唯一名称，以便它可以与 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic.url_for" target="_blank" rel="noopener"><code>url_for()</code></a>返回装饰功能</p>
</li>
</ul>
<h2 id="sanic-blueprints-模块"><a href="#sanic-blueprints-模块" class="headerlink" title="sanic.blueprints 模块"></a>sanic.blueprints 模块</h2><ul>
<li><p><em>class<em><code>sanic.blueprints.``Blueprint</code>(</em>name</em>, <em>url_prefix=None</em>, <em>host=None</em>, <em>version=None</em>, <em>strict_slashes=None</em>)</p>
<p>基类：<code>object``add_route</code>(<em>handler</em>, <em>uri</em>, <em>methods=frozenset({‘GET’})</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>version=None</em>, <em>name=None</em>, <em>stream=False</em>)从函数创建蓝图路由。参数<strong>handler</strong> – 用于处理URI请求的函数。接受带有视图类方法的函数或类实例。<strong>uri</strong> – 路由可访问的终结点。<strong>methods</strong> – 可接受的HTTP方法列表。<strong>host</strong> – 要使用的SANIC服务器的FQDN的IP地址。<strong>strict_slashes</strong> – 强制通过培训请求API URL <em>/<strong>*version</strong> – 蓝图版本<strong>name</strong> – URL的用户定义路由名称<strong>stream</strong> – 布尔值，指定处理程序是否为流处理程序返回函数或类实例<code>add_websocket_route</code>(*handler</em>, <em>uri</em>, <em>host=None</em>, <em>version=None</em>, <em>name=None</em>)从函数创建蓝图WebSocket路由。参数<strong>handler</strong> – 用于处理URI请求的函数。接受带有视图类方法的函数或类实例。<strong>uri</strong> – 路由可访问的终结点。<strong>host</strong> – 要使用的SANIC服务器的FQDN的IP地址。<strong>version</strong> – 蓝图版本<strong>name</strong> – 用于标识WebSocket路由的唯一名称返回函数或类实例<code>delete</code>(<em>uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>version=None</em>, <em>name=None</em>)在下添加API URL <strong>DELETE</strong> <em>HTTP</em> 方法参数<strong>uri</strong> – 要标记到的URL <strong>DELETE</strong> 方法 <em>HTTP<strong>*host</strong> – 要使用的服务的主机IP或FQDN<strong>strict_slashes</strong> – 指导 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic" target="_blank" rel="noopener"><code>sanic.app.Sanic</code></a> 检查请求URL是否需要使用 <em>/**</em>version** – API版本<strong>name</strong> – 可用于标识路由的唯一名称返回具有 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.blueprints.Blueprint.route" target="_blank" rel="noopener"><code>route()</code></a> 方法 的对象装饰器<code>exception</code>(**args</em>, <strong><em>kwargs</em>)此方法允许为有问题的当前蓝图创建全局异常处理程序。参数</strong>args<em>* – 处理程序要捕获的python异常列表<strong>kwargs</strong> – 要传递给异常处理程序的其他可选参数：返回修饰方法以处理任何在此蓝图下注册的路线。<code>get</code>(*uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>version=None</em>, <em>name=None</em>)在下添加API URL <strong>GET</strong> <em>HTTP</em> 方法参数<strong>uri</strong> – 要标记到的URL <strong>GET</strong> 方法 <em>HTTP<strong>*host</strong> – 要使用的服务的主机IP或FQDN<strong>strict_slashes</strong> – 指导 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic" target="_blank" rel="noopener"><code>sanic.app.Sanic</code></a> 检查请求URL是否需要使用 <em>/**</em>version** – API版本<strong>name</strong> – 可用于标识路由的唯一名称返回具有 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.blueprints.Blueprint.route" target="_blank" rel="noopener"><code>route()</code></a> 方法 的对象装饰器<em>static</em><code>group</code>(**blueprints</em>, <em>url_prefix=’’</em>)创建一个蓝图列表，可以选择在通用URL前缀下对其进行分组。参数<strong>blueprints</strong> – 要注册为组的蓝图<strong>url_prefix</strong> – 所有子前缀的URL路由<code>head</code>(<em>uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>version=None</em>, <em>name=None</em>)在下添加API URL <strong>HEAD</strong> <em>HTTP</em> 方法参数<strong>uri</strong> – 要标记到的URL <strong>HEAD</strong> 方法 <em>HTTP<strong>*host</strong> – 要使用的服务的主机IP或FQDN<strong>strict_slashes</strong> – 指导 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic" target="_blank" rel="noopener"><code>sanic.app.Sanic</code></a> 检查请求URL是否需要使用 <em>/**</em>version** – API版本<strong>name</strong> – 可用于标识路由的唯一名称返回具有 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.blueprints.Blueprint.route" target="_blank" rel="noopener"><code>route()</code></a> 方法 的对象装饰器<code>listener</code>(*event</em>)从修饰函数创建侦听器。参数<strong>event</strong> – 要收听的事件。<code>middleware</code>(<strong>args*, *</strong>kwargs<em>)从修饰函数创建蓝图中间件。参数<strong>args</strong> – 调用中间件时要使用的位置参数<strong>kwargs</strong> – 可用于中间件的可选关键字参数。<code>options</code>(*uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>version=None</em>, <em>name=None</em>)在下添加API URL <strong>OPTIONS</strong> <em>HTTP</em> 方法参数<strong>uri</strong> – 要标记到的URL <strong>OPTIONS</strong> 方法 <em>HTTP<strong>*host</strong> – 要使用的服务的主机IP或FQDN<strong>strict_slashes</strong> – 指导 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic" target="_blank" rel="noopener"><code>sanic.app.Sanic</code></a> 检查请求URL是否需要使用 <em>/**</em>version** – API版本<strong>name</strong> – 可用于标识路由的唯一名称返回具有 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.blueprints.Blueprint.route" target="_blank" rel="noopener"><code>route()</code></a> 方法 的对象装饰器<code>patch</code>(*uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>stream=False</em>, <em>version=None</em>, <em>name=None</em>)在下添加API URL <strong>PATCH</strong> <em>HTTP</em> 方法参数<strong>uri</strong> – 要标记到的URL <strong>PATCH</strong> 方法 <em>HTTP<strong>*host</strong> – 要使用的服务的主机IP或FQDN<strong>strict_slashes</strong> – 指导 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic" target="_blank" rel="noopener"><code>sanic.app.Sanic</code></a> 检查请求URL是否需要使用 <em>/**</em>version** – API版本<strong>name</strong> – 可用于标识路由的唯一名称返回具有 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.blueprints.Blueprint.route" target="_blank" rel="noopener"><code>route()</code></a> 方法 的对象装饰器<code>post</code>(*uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>stream=False</em>, <em>version=None</em>, <em>name=None</em>)在下添加API URL <strong>POST</strong> <em>HTTP</em> 方法参数<strong>uri</strong> – 要标记到的URL <strong>POST</strong> 方法 <em>HTTP<strong>*host</strong> – 要使用的服务的主机IP或FQDN<strong>strict_slashes</strong> – 指导 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic" target="_blank" rel="noopener"><code>sanic.app.Sanic</code></a> 检查请求URL是否需要使用 <em>/**</em>version** – API版本<strong>name</strong> – 可用于标识路由的唯一名称返回具有 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.blueprints.Blueprint.route" target="_blank" rel="noopener"><code>route()</code></a> 方法 的对象装饰器<code>put</code>(*uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>stream=False</em>, <em>version=None</em>, <em>name=None</em>)在下添加API URL <strong>PUT</strong> <em>HTTP</em> 方法参数<strong>uri</strong> – 要标记到的URL <strong>PUT</strong> 方法 <em>HTTP<strong>*host</strong> – 要使用的服务的主机IP或FQDN<strong>strict_slashes</strong> – 指导 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic" target="_blank" rel="noopener"><code>sanic.app.Sanic</code></a> 检查请求URL是否需要使用 <em>/**</em>version** – API版本<strong>name</strong> – 可用于标识路由的唯一名称返回具有 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.blueprints.Blueprint.route" target="_blank" rel="noopener"><code>route()</code></a> 方法 的对象装饰器<code>register</code>(*app</em>, <em>options</em>)将蓝图注册到sanic应用程序。参数<strong>app</strong> – 实例 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic" target="_blank" rel="noopener"><code>sanic.app.Sanic</code></a> 班<strong>options</strong> – 将蓝图注册到应用程序时要使用的选项。 <em>url_prefix</em> -覆盖蓝图前缀的URL前缀<code>route</code>(<em>uri</em>, <em>methods=frozenset({‘GET’})</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>stream=False</em>, <em>version=None</em>, <em>name=None</em>)从修饰函数创建蓝图路由。参数<strong>uri</strong> – 路由可访问的终结点。<strong>methods</strong> – 可接受的HTTP方法列表。<strong>host</strong> – 要使用的SANIC服务器的FQDN的IP地址。<strong>strict_slashes</strong> – 强制通过培训请求API URL <em>/<strong>*stream</strong> – 如果路由应该提供流支持<strong>version</strong> – 蓝图版本<strong>name</strong> – 用于标识路由的唯一名称：返回一个修饰方法，调用该方法时将返回一个对象类型的 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.blueprints.FutureRoute" target="_blank" rel="noopener"><code>FutureRoute</code></a><code>static</code>(*uri</em>, <em>file_or_directory</em>, <strong>args*, *</strong>kwargs<em>)从修饰函数创建蓝图静态路由。参数<strong>uri</strong> – 路由可访问的终结点。<strong>file_or_directory</strong> – 静态资产。<code>websocket</code>(*uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>version=None</em>, <em>name=None</em>)从修饰函数创建蓝图WebSocket路由。参数<strong>uri</strong> – 路由可访问的终结点。<strong>host</strong> – 要使用的SANIC服务器的FQDN的IP地址。<strong>strict_slashes</strong> – 强制通过培训请求API URL <em>/**</em>version** – 蓝图版本<strong>name</strong> – 用于标识WebSocket路由的唯一名称</p>
</li>
<li><p><em>class<em><code>sanic.blueprints.``FutureException</code>(</em>handler</em>, <em>args</em>, <em>kwargs</em>)</p>
<p>基类：<code>tuple</code><em>property</em><code>args</code>字段编号1的别名<em>property</em><code>handler</code>字段编号0的别名<em>property</em><code>kwargs</code>字段编号2的别名</p>
</li>
<li><p><em>class<em><code>sanic.blueprints.``FutureListener</code>(</em>handler</em>, <em>uri</em>, <em>methods</em>, <em>host</em>)</p>
<p>基类：<code>tuple</code><em>property</em><code>handler</code>字段编号0的别名<em>property</em><code>host</code>字段编号3的别名<em>property</em><code>methods</code>字段编号2的别名<em>property</em><code>uri</code>字段编号1的别名</p>
</li>
<li><p><em>class<em><code>sanic.blueprints.``FutureMiddleware</code>(</em>middleware</em>, <em>args</em>, <em>kwargs</em>)</p>
<p>基类：<code>tuple</code><em>property</em><code>args</code>字段编号1的别名<em>property</em><code>kwargs</code>字段编号2的别名<em>property</em><code>middleware</code>字段编号0的别名</p>
</li>
<li><p><em>class<em><code>sanic.blueprints.``FutureRoute</code>(</em>handler</em>, <em>uri</em>, <em>methods</em>, <em>host</em>, <em>strict_slashes</em>, <em>stream</em>, <em>version</em>, <em>name</em>)</p>
<p>基类：<code>tuple</code><em>property</em><code>handler</code>字段编号0的别名<em>property</em><code>host</code>字段编号3的别名<em>property</em><code>methods</code>字段编号2的别名<em>property</em><code>name</code>字段编号7的别名<em>property</em><code>stream</code>字段5的别名<em>property</em><code>strict_slashes</code>字段编号4的别名<em>property</em><code>uri</code>字段编号1的别名<em>property</em><code>version</code>字段编号6的别名</p>
</li>
<li><p><em>class<em><code>sanic.blueprints.``FutureStatic</code>(</em>uri</em>, <em>file_or_directory</em>, <em>args</em>, <em>kwargs</em>)</p>
<p>基类：<code>tuple</code><em>property</em><code>args</code>字段编号2的别名<em>property</em><code>file_or_directory</code>字段编号1的别名<em>property</em><code>kwargs</code>字段编号3的别名<em>property</em><code>uri</code>字段编号0的别名</p>
</li>
</ul>
<h2 id="sanic-bluent-组模块"><a href="#sanic-bluent-组模块" class="headerlink" title="sanic.bluent_组模块"></a>sanic.bluent_组模块</h2><ul>
<li><p><em>class<em><code>sanic.blueprint_group.``BlueprintGroup</code>(</em>url_prefix=None</em>)</p>
<p>基类：<code>collections.abc.MutableSequence</code>这个类提供了一种机制来使用 Blueprint.group 方法。为了避免重新编写一些现有的实现，这个类提供了一个自定义迭代器实现，它允许您将这个类的对象用作现有实现中的列表/元组。<em>property<em><code>blueprints</code>检索此组下所有可用蓝图的列表。：返回：蓝图实例列表<code>insert</code>(</em>index: int</em>, <em>item: object</em>) → None抽象类 MutableSequence 利用此插入方法执行 BlueprintGroup.append 操作。参数<strong>index</strong> – 用于删除新蓝图项的索引<strong>item</strong> – 新的 Blueprint 对象。返回没有<code>middleware</code>(<strong>args*, *</strong>kwargs<em>)可以用来实现属于这个特定蓝图组的所有蓝图的中间件插件的装饰器。对于嵌套的蓝图组，相同的中间件递归地应用于每个蓝图。参数*</em>args** – 要使用中间件的可选位置参数<strong>kwargs</strong> – 用于中间件的可选关键字arg返回应用中间件的部分功能<em>property</em><code>url_prefix</code>检索当前蓝图组使用的URL前缀：返回：带URL前缀的字符串</p>
</li>
</ul>
<h2 id="sanic-config模块"><a href="#sanic-config模块" class="headerlink" title="sanic.config模块"></a>sanic.config模块</h2><ul>
<li><p><em>class<em><code>sanic.config.``Config</code>(</em>defaults=None</em>, <em>load_env=True</em>, <em>keep_alive=None</em>)</p>
<p>基类：<code>dict``from_envvar</code>(<em>variable_name</em>)从指向配置文件的环境变量加载配置。参数<strong>variable_name</strong> – 环境变量的名称返回布尔。 <code>True</code> 如果能够加载配置， <code>False</code> 否则。<code>from_object</code>(<em>obj</em>)更新给定对象的值。对象通常是模块或类。只有该对象中的大写变量存储在配置中。示例用法：<code>from yourapplication import default_config app.config.from_object(default_config)  or also: app.config.from_object(&#39;myproject.config.MyConfigClass&#39;)</code>不应使用此函数加载实际配置，而应使用配置默认值。实际配置应加载 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.config.Config.from_pyfile" target="_blank" rel="noopener"><code>from_pyfile()</code></a> 最好是从不在包内的位置安装，因为包可能在系统范围内安装。参数<strong>obj</strong> – 保存配置的对象<code>from_pyfile</code>(<em>filename</em>)从python文件更新配置中的值。只有该模块中的大写变量存储在配置中。参数<strong>filename</strong> – 配置文件的绝对路径<code>load_environment_vars</code>(<em>prefix=’SANIC_’</em>)查找前缀环境变量并将其应用于配置（如果存在）。</p>
</li>
<li><p><code>sanic.config.``strtobool</code>(<em>val</em>)</p>
<p>此函数是从distutils.utils中借用的。虽然distuils是stdlib的一部分，但在主应用程序代码中使用distuils感觉很奇怪。该函数被修改为执行其会话并实际返回bool而不是int。</p>
</li>
</ul>
<h2 id="sanic-constants模块"><a href="#sanic-constants模块" class="headerlink" title="sanic.constants模块"></a>sanic.constants模块</h2><h2 id="sanic-cookies模块"><a href="#sanic-cookies模块" class="headerlink" title="sanic.cookies模块"></a>sanic.cookies模块</h2><ul>
<li><p><em>class<em><code>sanic.cookies.``Cookie</code>(</em>key</em>, <em>value</em>)</p>
<p>基类：<code>dict</code>从simplecookie gottagofast中删去的莫尔斯电码<code>encode</code>(<em>encoding</em>)按照开发人员指示的特定编码类型对cookie内容进行编码。利用 <code>str.encode()</code> 方法由python提供。此方法可用于编码和嵌入 <code>utf-8</code> 内容到cookies中。参数<strong>encoding</strong> – 与cookie一起使用的编码返回在选择的编解码器中编码的cookie。除了UnicodeEncodeError</p>
</li>
<li><p><em>class<em><code>sanic.cookies.``CookieJar</code>(</em>headers</em>)</p>
<p>基类：<code>dict</code>当添加和删除cookie时，cookiejar会动态地写入头，通过使用multiHeader类提供一个唯一的键来编码设置cookie，从而绕过了每个名称一个头的限制。</p>
</li>
</ul>
<h2 id="sanic-exceptions模块"><a href="#sanic-exceptions模块" class="headerlink" title="sanic.exceptions模块"></a>sanic.exceptions模块</h2><ul>
<li><p><em>exception<em><code>sanic.exceptions.``ContentRangeError</code>(</em>message</em>, <em>content_range</em>)</p>
<p>基类：<a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.exceptions.SanicException" target="_blank" rel="noopener"><code>sanic.exceptions.SanicException</code></a><code>status_code</code><em>= 416</em></p>
</li>
<li><p><em>exception<em><code>sanic.exceptions.``FileNotFound</code>(</em>message</em>, <em>path</em>, <em>relative_url</em>)</p>
<p>基类：<a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.exceptions.NotFound" target="_blank" rel="noopener"><code>sanic.exceptions.NotFound</code></a></p>
</li>
<li><p><em>exception<em><code>sanic.exceptions.``Forbidden</code>(</em>message</em>, <em>status_code=None</em>)</p>
<p>基类：<a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.exceptions.SanicException" target="_blank" rel="noopener"><code>sanic.exceptions.SanicException</code></a><code>status_code</code><em>= 403</em></p>
</li>
<li><p><em>exception<em><code>sanic.exceptions.``HeaderExpectationFailed</code>(</em>message</em>, <em>status_code=None</em>)</p>
<p>基类：<a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.exceptions.SanicException" target="_blank" rel="noopener"><code>sanic.exceptions.SanicException</code></a><code>status_code</code><em>= 417</em></p>
</li>
<li><p><em>exception<em><code>sanic.exceptions.``HeaderNotFound</code>(</em>message</em>, <em>status_code=None</em>)</p>
<p>基类：<a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.exceptions.InvalidUsage" target="_blank" rel="noopener"><code>sanic.exceptions.InvalidUsage</code></a></p>
</li>
<li><p><em>exception<em><code>sanic.exceptions.``InvalidRangeType</code>(</em>message</em>, <em>content_range</em>)</p>
<p>基类：<a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.exceptions.ContentRangeError" target="_blank" rel="noopener"><code>sanic.exceptions.ContentRangeError</code></a></p>
</li>
<li><p><em>exception<em><code>sanic.exceptions.``InvalidUsage</code>(</em>message</em>, <em>status_code=None</em>)</p>
<p>基类：<a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.exceptions.SanicException" target="_blank" rel="noopener"><code>sanic.exceptions.SanicException</code></a><code>status_code</code><em>= 400</em></p>
</li>
<li><p><em>exception<em><code>sanic.exceptions.``MethodNotSupported</code>(</em>message</em>, <em>method</em>, <em>allowed_methods</em>)</p>
<p>基类：<a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.exceptions.SanicException" target="_blank" rel="noopener"><code>sanic.exceptions.SanicException</code></a><code>status_code</code><em>= 405</em></p>
</li>
<li><p><em>exception<em><code>sanic.exceptions.``NotFound</code>(</em>message</em>, <em>status_code=None</em>)</p>
<p>基类：<a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.exceptions.SanicException" target="_blank" rel="noopener"><code>sanic.exceptions.SanicException</code></a><code>status_code</code><em>= 404</em></p>
</li>
<li><p><em>exception<em><code>sanic.exceptions.``PayloadTooLarge</code>(</em>message</em>, <em>status_code=None</em>)</p>
<p>基类：<a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.exceptions.SanicException" target="_blank" rel="noopener"><code>sanic.exceptions.SanicException</code></a><code>status_code</code><em>= 413</em></p>
</li>
<li><p><em>exception<em><code>sanic.exceptions.``PyFileError</code>(</em>file</em>)</p>
<p>基类：<code>Exception</code></p>
</li>
<li><p><em>exception<em><code>sanic.exceptions.``RequestTimeout</code>(</em>message</em>, <em>status_code=None</em>)</p>
<p>基类：<a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.exceptions.SanicException" target="_blank" rel="noopener"><code>sanic.exceptions.SanicException</code></a>Web服务器（运行网站）认为在1）客户端和服务器之间建立IP连接（套接字）和2）在该套接字上接收到任何数据之间的时间间隔太长，因此服务器已断开连接。套接字连接实际上已丢失-Web服务器已在该特定套接字连接上“超时”。<code>status_code</code><em>= 408</em></p>
</li>
<li><p><em>exception<em><code>sanic.exceptions.``SanicException</code>(</em>message</em>, <em>status_code=None</em>)</p>
<p>基类：<code>Exception</code></p>
</li>
<li><p><em>exception<em><code>sanic.exceptions.``ServerError</code>(</em>message</em>, <em>status_code=None</em>)</p>
<p>基类：<a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.exceptions.SanicException" target="_blank" rel="noopener"><code>sanic.exceptions.SanicException</code></a><code>status_code</code><em>= 500</em></p>
</li>
<li><p><em>exception<em><code>sanic.exceptions.``ServiceUnavailable</code>(</em>message</em>, <em>status_code=None</em>)</p>
<p>基类：<a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.exceptions.SanicException" target="_blank" rel="noopener"><code>sanic.exceptions.SanicException</code></a>服务器当前不可用（因为它因维护而过载或停机）。一般来说，这是一种临时状态。<code>status_code</code><em>= 503</em></p>
</li>
<li><p><em>exception<em><code>sanic.exceptions.``URLBuildError</code>(</em>message</em>, <em>status_code=None</em>)</p>
<p>基类：<a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.exceptions.ServerError" target="_blank" rel="noopener"><code>sanic.exceptions.ServerError</code></a></p>
</li>
<li><p><em>exception<em><code>sanic.exceptions.``Unauthorized</code>(</em>message</em>, <em>status_code=None</em>, <em>scheme=None</em>, <em>**kwargs</em>)</p>
<p>基类：<a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.exceptions.SanicException" target="_blank" rel="noopener"><code>sanic.exceptions.SanicException</code></a>未经授权的异常（401 HTTP状态代码）。参数<strong>message</strong> – 描述异常的消息。<strong>status_code</strong> – HTTP状态代码。<strong>scheme</strong> – 要使用的身份验证方案的名称。当存在时，Kwargs用于完成WWW身份验证头。实例：<code># With a Basic auth-scheme, realm MUST be present: raise Unauthorized(&quot;Auth required.&quot;,                    scheme=&quot;Basic&quot;,                    realm=&quot;Restricted Area&quot;)  # With a Digest auth-scheme, things are a bit more complicated: raise Unauthorized(&quot;Auth required.&quot;,                    scheme=&quot;Digest&quot;,                    realm=&quot;Restricted Area&quot;,                    qop=&quot;auth, auth-int&quot;,                    algorithm=&quot;MD5&quot;,                    nonce=&quot;abcdef&quot;,                    opaque=&quot;zyxwvu&quot;)  # With a Bearer auth-scheme, realm is optional so you can write: raise Unauthorized(&quot;Auth required.&quot;, scheme=&quot;Bearer&quot;)  # or, if you want to specify the realm: raise Unauthorized(&quot;Auth required.&quot;,                    scheme=&quot;Bearer&quot;,                    realm=&quot;Restricted Area&quot;) ``status_code</code><em>= 401</em></p>
</li>
<li><p><code>sanic.exceptions.``abort</code>(<em>status_code</em>, <em>message=None</em>)</p>
<p>基于SaniceException引发异常。返回适用于给定状态代码的HTTP响应消息，除非提供。参数<strong>status_code</strong> – 要返回的HTTP状态代码。<strong>message</strong> – HTTP响应主体。默认为给定状态代码的response.py中的消息。</p>
</li>
<li><p><code>sanic.exceptions.``add_status_code</code>(<em>code</em>)</p>
<p>用于将异常添加到 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.exceptions.SanicException" target="_blank" rel="noopener"><code>SanicException</code></a> .</p>
</li>
</ul>
<h2 id="sanic-handlers模块"><a href="#sanic-handlers模块" class="headerlink" title="sanic.handlers模块"></a>sanic.handlers模块</h2><ul>
<li><p><em>class<em><code>sanic.handlers.``ContentRangeHandler</code>(</em>request</em>, <em>stats</em>)</p>
<p>基类：<code>object</code>解析和处理传入请求头以提取内容范围信息的机制。参数<strong>request</strong> (<a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.request.Request" target="_blank" rel="noopener"><code>sanic.request.Request</code></a>) – 传入API请求<strong>stats</strong> (<code>posix.stat_result</code>) – 与内容相关的统计信息变量<a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.handlers.ContentRangeHandler.start" target="_blank" rel="noopener"><strong>start</strong></a> – 内容范围开始<a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.handlers.ContentRangeHandler.end" target="_blank" rel="noopener"><strong>end</strong></a> – 内容范围结束<a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.handlers.ContentRangeHandler.size" target="_blank" rel="noopener"><strong>size</strong></a> – 内容的长度<a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.handlers.ContentRangeHandler.total" target="_blank" rel="noopener"><strong>total</strong></a> – 总尺寸由 <code>posix.stat_result</code> 实例<a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.handlers.ContentRangeHandler.headers" target="_blank" rel="noopener"><strong>ContentRangeHandler.headers</strong></a> – 内容范围标题 <code>dict``end``headers``size``start``total</code></p>
</li>
<li><p><em>class</em><code>sanic.handlers.``ErrorHandler</code></p>
<p>基类：<code>object</code>提供 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic" target="_blank" rel="noopener"><code>sanic.app.Sanic</code></a> 具有处理和处理任何和所有未捕获异常的机制的应用程序，其方式由应用程序开发人员设置。这个错误处理框架内置在核心中，开发人员可以对其进行扩展，以执行各种任务，从记录错误状态到将其报告给可用于实时警报系统的外部服务。<code>add</code>(<em>exception</em>, <em>handler</em>)向已存在的处理程序对象添加新的异常处理程序。参数<strong>exception</strong> (<a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.exceptions.SanicException" target="_blank" rel="noopener"><code>sanic.exceptions.SanicException</code></a> or <code>Exception</code>) – 需要处理的异常类型<strong>handler</strong> (<code>function</code>) – 对将处理异常的方法的引用返回没有<code>cached_handlers</code><em>= None<em><code>default</code>(</em>request</em>, <em>exception</em>)为以下对象提供默认行为 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.handlers.ErrorHandler" target="_blank" rel="noopener"><code>ErrorHandler</code></a> . 如果开发者选择 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.handlers.ErrorHandler" target="_blank" rel="noopener"><code>ErrorHandler</code></a> 它们可以为这个方法提供一个自定义的实现，使其以他们认为合适的方式工作。参数<strong>request</strong> (<a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.request.Request" target="_blank" rel="noopener"><code>sanic.request.Request</code></a>) – 传入请求<strong>exception</strong> (<a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.exceptions.SanicException" target="_blank" rel="noopener"><code>sanic.exceptions.SanicException</code></a> or <code>Exception</code>) – 异常对象返回<code>handlers</code><em>= None<em><code>log</code>(</em>message</em>, <em>level=’error’</em>)已弃用，请勿使用。<code>lookup</code>(<em>exception</em>)查找的现有实例 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.handlers.ErrorHandler" target="_blank" rel="noopener"><code>ErrorHandler</code></a> 并获取特定类型异常的注册处理程序。此方法利用dict查找加快检索过程。参数<strong>exception</strong> (<a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.exceptions.SanicException" target="_blank" rel="noopener"><code>sanic.exceptions.SanicException</code></a> or <code>Exception</code>) – 异常类型返回已注册函数（如果找到） <code>None</code> 否则<code>response</code>(<em>request</em>, <em>exception</em>)获取并执行异常处理程序并返回响应对象参数<strong>request</strong> (<a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.request.Request" target="_blank" rel="noopener"><code>sanic.request.Request</code></a>) – 实例 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.request.Request" target="_blank" rel="noopener"><code>sanic.request.Request</code></a><strong>exception</strong> (<a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.exceptions.SanicException" target="_blank" rel="noopener"><code>sanic.exceptions.SanicException</code></a> or <code>Exception</code>) – 要处理的异常返回包装从中获取的返回值 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.handlers.ErrorHandler.default" target="_blank" rel="noopener"><code>default()</code></a> 或为该异常类型注册的处理程序。</p>
</li>
</ul>
<h2 id="sanic-log模块"><a href="#sanic-log模块" class="headerlink" title="sanic.log模块"></a>sanic.log模块</h2><h2 id="sanic-请求模块"><a href="#sanic-请求模块" class="headerlink" title="sanic.请求模块"></a>sanic.请求模块</h2><ul>
<li><p><em>class<em><code>sanic.request.``File</code>(</em>type</em>, <em>body</em>, <em>name</em>)</p>
<p>基类：<code>tuple</code><em>property</em><code>body</code>字段编号1的别名<em>property</em><code>name</code>字段编号2的别名<em>property</em><code>type</code>字段编号0的别名</p>
</li>
<li><p><em>class<em><code>sanic.request.``Request</code>(</em>url_bytes</em>, <em>headers</em>, <em>version</em>, <em>method</em>, <em>transport</em>, <em>app</em>)</p>
<p>基类：<code>dict</code>HTTP请求的属性，如URL、头等。<code>app</code><em>property<em><code>args</code>解析方法 query_string 使用 urllib.parse.parse_qs . 此方法用于 args 财产。如果需要更改默认参数，可以直接使用。：param keep_blank_values：指示中是否有空值的标志编码查询的百分比应视为空字符串。一个真值表示空格应保留为空字符串。默认的false值表示忽略空白值，并将其视为不包括在内。参数*</em>strict_parsing** (*bool</em>) – 指示如何处理分析错误的标志。如果为false（默认值），则默认忽略错误。如果为true，则错误会引发ValueError异常。<strong>encoding</strong> (<em>str</em>) – 指定如何将百分比编码序列解码为Unicode字符（bytes.decode（）方法接受）。<strong>errors</strong> (<em>str</em>) – 指定如何将百分比编码序列解码为Unicode字符（bytes.decode（）方法接受）。返回RequestParameters<code>body``body_finish</code>()<code>body_init</code>()<code>body_push</code>(<em>data</em>)<em>property<em><code>content_type</code></em>property<em><code>cookies``endpoint</code></em>property<em><code>files</code></em>property<em><code>form``get_args</code>(</em>keep_blank_values: bool = False</em>, <em>strict_parsing: bool = False</em>, <em>encoding: str = ‘utf-8’</em>, <em>errors: str = ‘replace’</em>) → sanic.request.RequestParameters解析方法 query_string 使用 urllib.parse.parse_qs . 此方法用于 args 财产。如果需要更改默认参数，可以直接使用。：param keep_blank_values：指示中是否有空值的标志编码查询的百分比应视为空字符串。一个真值表示空格应保留为空字符串。默认的false值表示忽略空白值，并将其视为不包括在内。参数<strong>strict_parsing</strong> (<em>bool</em>) – 指示如何处理分析错误的标志。如果为false（默认值），则默认忽略错误。如果为true，则错误会引发ValueError异常。<strong>encoding</strong> (<em>str</em>) – 指定如何将百分比编码序列解码为Unicode字符（bytes.decode（）方法接受）。<strong>errors</strong> (<em>str</em>) – 指定如何将百分比编码序列解码为Unicode字符（bytes.decode（）方法接受）。返回RequestParameters<code>get_query_args</code>(<em>keep_blank_values: bool = False</em>, <em>strict_parsing: bool = False</em>, <em>encoding: str = ‘utf-8’</em>, <em>errors: str = ‘replace’</em>) → list解析方法 query_string 使用 urllib.parse.parse_qsl . 此方法用于 query_args 财产。如果需要更改默认参数，可以直接使用。：param keep_blank_values：指示中是否有空值的标志编码查询的百分比应视为空字符串。一个真值表示空格应保留为空字符串。默认的false值表示忽略空白值，并将其视为不包括在内。参数<strong>strict_parsing</strong> (<em>bool</em>) – 指示如何处理分析错误的标志。如果为false（默认值），则默认忽略错误。如果为true，则错误会引发ValueError异常。<strong>encoding</strong> (<em>str</em>) – 指定如何将百分比编码序列解码为Unicode字符（bytes.decode（）方法接受）。<strong>errors</strong> (<em>str</em>) – 指定如何将百分比编码序列解码为Unicode字符（bytes.decode（）方法接受）。返回列表<code>headers</code><em>property<em><code>host</code>返回头中指定的主机可能包含端口号。</em>property<em><code>ip</code>返回套接字的对等IP</em>property<em><code>json``load_json</code>(</em>loads=<built-in function loads></built-in></em>)<em>property<em><code>match_info</code>解析路由后返回匹配信息<code>method``parsed_args``parsed_files``parsed_form``parsed_json``parsed_not_grouped_args</code></em>property<em><code>path</code></em>property<em><code>port</code>返回套接字的对等端口</em>property<em><code>query_args</code>解析方法 query_string 使用 urllib.parse.parse_qsl . 此方法用于 query_args 财产。如果需要更改默认参数，可以直接使用。：param keep_blank_values：指示中是否有空值的标志编码查询的百分比应视为空字符串。一个真值表示空格应保留为空字符串。默认的false值表示忽略空白值，并将其视为不包括在内。参数*</em>strict_parsing** (*bool</em>) – 指示如何处理分析错误的标志。如果为false（默认值），则默认忽略错误。如果为true，则错误会引发ValueError异常。<strong>encoding</strong> (<em>str</em>) – 指定如何将百分比编码序列解码为Unicode字符（bytes.decode（）方法接受）。<strong>errors</strong> (<em>str</em>) – 指定如何将百分比编码序列解码为Unicode字符（bytes.decode（）方法接受）。返回列表<em>property<em><code>query_string</code></em>property<em><code>raw_args``raw_url</code></em>property<em><code>remote_addr</code>尝试基于x-forwarded-for或x-real-ip返回原始客户端IP。如果HTTP头不可用或不受信任，则返回空字符串。返回原始客户端IP。</em>property<em><code>scheme</code>尝试获取请求方案。按以下顺序寻找价值： x-forwarded-proto 页眉， x-scheme Header，Sanic应用程序本身。返回HTTP协议 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#id1" target="_blank" rel="noopener">|https|</a> ws wss或头文件给出的任意值。返回类型str</em>property<em><code>server_name</code>尝试按以下顺序获取服务器的主机名： config.SERVER_NAME ， x-forwarded-host 页眉， <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.request.Request.host" target="_blank" rel="noopener"><code>Request.host()</code></a>返回没有端口号的服务器名称返回类型str</em>property<em><code>server_port</code>尝试按以下顺序获取服务器端口： x-forwarded-port 页眉， <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.request.Request.host" target="_blank" rel="noopener"><code>Request.host()</code></a> ，传输层套接字使用的实际端口。：返回：服务器端口：rtype:int</em>property<em><code>socket``stream</code></em>property<em><code>token</code>尝试返回auth头标记。返回与请求相关的令牌<code>transport``uri_template</code></em>property<em><code>url``url_for</code>(</em>view_name</em>, <strong><em>kwargs</em>)等同于 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.Sanic.url_for" target="_blank" rel="noopener"><code>sanic.Sanic.url_for()</code></a> ，但自动确定 scheme and netloc base on the request. Since this method is aiming to generate correct schema &amp; netloc, <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#id1" target="_blank" rel="noopener">`</a>_ 暗示为“external”。参数</strong>kwargs** – 采用与中相同的参数 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.Sanic.url_for" target="_blank" rel="noopener"><code>sanic.Sanic.url_for()</code></a>返回给定视图的绝对URL返回类型str<code>version</code></p>
</li>
<li><p><em>class</em><code>sanic.request.``RequestParameters</code></p>
<p>基类：<code>dict</code>托管一个以列表为值的dict，其中get返回列表的第一个值，get list返回整个shebang<code>get</code>(<em>name</em>, <em>default=None</em>)返回第一个值，默认值或实际值<code>getlist</code>(<em>name</em>, <em>default=None</em>)返回整个列表</p>
</li>
<li><p><em>class<em><code>sanic.request.``StreamBuffer</code>(</em>buffer_size=100</em>)</p>
<p>基类：<code>object``is_full</code>()</p>
</li>
<li><p><code>sanic.request.``parse_multipart_form</code>(<em>body</em>, <em>boundary</em>)</p>
<p>解析请求体并返回字段和文件参数<strong>body</strong> – 字节请求正文<strong>boundary</strong> – 字节多部分边界返回字段（请求参数）、文件（请求参数）</p>
</li>
</ul>
<h2 id="sanic-response模块"><a href="#sanic-response模块" class="headerlink" title="sanic.response模块"></a>sanic.response模块</h2><ul>
<li><p><em>class</em><code>sanic.response.``BaseHTTPResponse</code></p>
<p>基类：<code>object</code><em>property</em><code>cookies</code></p>
</li>
<li><p><em>class<em><code>sanic.response.``HTTPResponse</code>(</em>body=None</em>, <em>status=200</em>, <em>headers=None</em>, <em>content_type=’text/plain’</em>, <em>body_bytes=b’’</em>)</p>
<p>基类：<a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.response.BaseHTTPResponse" target="_blank" rel="noopener"><code>sanic.response.BaseHTTPResponse</code></a><code>body``content_type</code><em>property<em><code>cookies``headers``output</code>(</em>version=’1.1’</em>, <em>keep_alive=False</em>, <em>keep_alive_timeout=None</em>)<code>status</code></p>
</li>
<li><p><em>class<em><code>sanic.response.``StreamingHTTPResponse</code>(</em>streaming_fn</em>, <em>status=200</em>, <em>headers=None</em>, <em>content_type=’text/plain’</em>, <em>chunked=True</em>)</p>
<p>基类：<a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.response.BaseHTTPResponse" target="_blank" rel="noopener"><code>sanic.response.BaseHTTPResponse</code></a><code>chunked``content_type``get_headers</code>(<em>version=’1.1’</em>, <em>keep_alive=False</em>, <em>keep_alive_timeout=None</em>)<code>headers``protocol``status``streaming_fn</code></p>
</li>
<li><p><code>sanic.response.``html</code>(<em>body</em>, <em>status=200</em>, <em>headers=None</em>)</p>
<p>返回具有HTML格式的正文的响应对象。参数<strong>body</strong> – 要编码的响应数据。<strong>status</strong> – 响应代码。<strong>headers</strong> – 自定义标题。</p>
</li>
<li><p><code>sanic.response.``json</code>(<em>body</em>, <em>status=200</em>, <em>headers=None</em>, <em>content_type=’application/json’</em>, <em>dumps=<built-in function dumps></built-in></em>, <em>**kwargs</em>)</p>
<p>返回主体为JSON格式的响应对象。参数<strong>body</strong> – 要序列化的响应数据。<strong>status</strong> – 响应代码。<strong>headers</strong> – 自定义标题。<strong>kwargs</strong> – 传递给JSON编码器的其余参数。</p>
</li>
<li><p><code>sanic.response.``raw</code>(<em>body</em>, <em>status=200</em>, <em>headers=None</em>, <em>content_type=’application/octet-stream’</em>)</p>
<p>返回不编码正文的响应对象。参数<strong>body</strong> – 响应数据。<strong>status</strong> – 响应代码。<strong>headers</strong> – 自定义标题。<strong>content_type</strong> – 响应的内容类型（字符串）。</p>
</li>
<li><p><code>sanic.response.``redirect</code>(<em>to</em>, <em>headers=None</em>, <em>status=302</em>, <em>content_type=’text/html; charset=utf-8’</em>)</p>
<p>中止执行并导致302重定向（默认情况下）。参数<strong>to</strong> – 要重定向到的路径或完全限定的URL<strong>headers</strong> – 要包含在新请求中的头的可选dict<strong>status</strong> – 新请求的状态代码（int），默认为302<strong>content_type</strong> – 响应的内容类型（字符串）返回重定向响应</p>
</li>
<li><p><code>sanic.response.``stream</code>(<em>streaming_fn</em>, <em>status=200</em>, <em>headers=None</em>, <em>content_type=’text/plain; charset=utf-8’</em>, <em>chunked=True</em>)</p>
<p>接受连体衣 streaming_fn 可用于将块写入流响应。返回A StreamingHTTPResponse .示例用法：<code>@app.route(&quot;/&quot;) async def index(request):     async def streaming_fn(response):         await response.write(&#39;foo&#39;)         await response.write(&#39;bar&#39;)      return stream(streaming_fn, content_type=&#39;text/plain&#39;)</code>参数<strong>streaming_fn</strong> – 协同程序接受响应并将内容写入该响应。<strong>mime_type</strong> – 特定的mime_类型。<strong>headers</strong> – 自定义标题。<strong>chunked</strong> – 启用或禁用分块传输编码</p>
</li>
<li><p><code>sanic.response.``text</code>(<em>body</em>, <em>status=200</em>, <em>headers=None</em>, <em>content_type=’text/plain; charset=utf-8’</em>)</p>
<p>返回正文为文本格式的响应对象。参数<strong>body</strong> – 要编码的响应数据。<strong>status</strong> – 响应代码。<strong>headers</strong> – 自定义标题。<strong>content_type</strong> – 响应的内容类型（字符串）</p>
</li>
</ul>
<h2 id="sanic-路由器模块"><a href="#sanic-路由器模块" class="headerlink" title="sanic.路由器模块"></a>sanic.路由器模块</h2><ul>
<li><p><em>class<em><code>sanic.router.``Parameter</code>(</em>name</em>, <em>cast</em>)</p>
<p>基类：<code>tuple</code><em>property</em><code>cast</code>字段编号1的别名<em>property</em><code>name</code>字段编号0的别名</p>
</li>
<li><p><em>exception</em><code>sanic.router.``ParameterNameConflicts</code></p>
<p>基类：<code>Exception</code></p>
</li>
<li><p><em>class<em><code>sanic.router.``Route</code>(</em>handler</em>, <em>methods</em>, <em>pattern</em>, <em>parameters</em>, <em>name</em>, <em>uri</em>)</p>
<p>基类：<code>tuple</code><em>property</em><code>handler</code>字段编号0的别名<em>property</em><code>methods</code>字段编号1的别名<em>property</em><code>name</code>字段编号4的别名<em>property</em><code>parameters</code>字段编号3的别名<em>property</em><code>pattern</code>字段编号2的别名<em>property</em><code>uri</code>字段5的别名</p>
</li>
<li><p><em>exception</em><code>sanic.router.``RouteDoesNotExist</code></p>
<p>基类：<code>Exception</code></p>
</li>
<li><p><em>exception</em><code>sanic.router.``RouteExists</code></p>
<p>基类：<code>Exception</code></p>
</li>
<li><p><em>class</em><code>sanic.router.``Router</code></p>
<p>基类：<code>object</code>路由器支持带参数和方法检查的基本路由用途：<code>@sanic.route(&#39;/my/url/&lt;my_param&gt;&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;, ...]) def my_route(request, my_param):     do stuff...</code>或<code>@sanic.route(&#39;/my/url/&lt;my_param:my_type&gt;&#39;, methods[&#39;GET&#39;, &#39;POST&#39;, ...]) def my_route_with_type(request, my_param: my_type):     do stuff...</code>参数将作为关键字参数传递给请求处理函数。提供的参数也可以通过将：type附加到<parameter>来具有类型。给定的参数必须能够类型化。如果未提供类型，则应提供字符串。正则表达式也可以作为类型传入。为函数提供的参数将始终是一个字符串，与类型无关。<code>add</code>(<em>uri</em>, <em>methods</em>, <em>handler</em>, <em>host=None</em>, <em>strict_slashes=False</em>, <em>version=None</em>, <em>name=None</em>)将处理程序添加到路由列表参数<strong>uri</strong> – 匹配路径<strong>methods</strong> – 接受方法名称的序列。如果没有提供，则允许使用任何方法<strong>handler</strong> – 请求处理程序函数。执行时，它应该提供一个响应对象。<strong>strict_slashes</strong> – 严格到尾随斜线<strong>version</strong> – 路线或蓝图的当前版本。更多详细信息，请参阅文档。返回没有什么<em>static<em><code>check_dynamic_route_exists</code>(</em>pattern</em>, <em>routes_to_check</em>, <em>parameters</em>)根据URL模式和参数的比较，检查所提供的路由列表中是否存在URL模式。参数<strong>pattern</strong> – URL参数模式<strong>routes_to_check</strong> – 动态路由列表，可哈希路由或不可哈希路由。<strong>parameters</strong> – 名单 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.router.Parameter" target="_blank" rel="noopener"><code>Parameter</code></a> 项目返回如果存在匹配路由，则为索引和路由的元组；其他-1表示索引，无表示路由<code>find_route_by_view_name</code>根据指定的视图名称在路由器中查找路由。参数<strong>view_name</strong> – 要搜索的视图名称字符串<strong>kwargs</strong> – 附加参数，通常用于静态文件返回包含（uri，route）的元组<code>get</code>(<em>request</em>)根据请求的URL获取请求处理程序，或引发错误参数<strong>request</strong> – 请求对象返回处理程序、参数、关键字参数<code>get_supported_methods</code>(<em>url</em>)获取URL和可选主机的支持方法列表。参数<strong>url</strong> – URL字符串（包括主机）返回支持方法的冻结集<code>is_stream_handler</code>(<em>request</em>)请求的处理程序是否为流。：param请求：请求对象：返回：bool<code>parameter_pattern</code><em>= re.compile(‘&lt;(.+?)&gt;’)*<em>classmethod</em><code>parse_parameter_string</code>(*parameter_string</em>)将参数字符串解析为其组成名称、类型和模式例如：：<code>parse_parameter_string(&#39;&lt;param_one:[A-z]&gt;&#39;)</code> -&gt;     (‘param_one’, str, ‘[A-z]’) <code>参数**parameter_string** -- 解析字符串返回包含的元组（参数_name、参数_type、参数_pattern）</code>remove<code>(*uri*, *clean_cache=True*, *host=None*)</code>routes_always_check<code>*= None*</code>routes_dynamic<code>*= None*</code>routes_static`<em>= None</em></parameter></p>
</li>
<li><p><code>sanic.router.``url_hash</code>(<em>url</em>)</p>
</li>
</ul>
<h2 id="sanic-server模块"><a href="#sanic-server模块" class="headerlink" title="sanic.server模块"></a>sanic.server模块</h2><ul>
<li><p><em>class<em><code>sanic.server.``HttpProtocol</code>(**</em>, *loop</em>, <em>app</em>, <em>request_handler</em>, <em>error_handler</em>, <em>signal=&lt;sanic.server.Signal object&gt;</em>, <em>connections=None</em>, <em>request_timeout=60</em>, <em>response_timeout=60</em>, <em>keep_alive_timeout=5</em>, <em>request_max_size=None</em>, <em>request_buffer_queue_size=100</em>, <em>request_class=None</em>, <em>access_log=True</em>, <em>keep_alive=True</em>, <em>is_request_stream=False</em>, <em>router=None</em>, <em>state=None</em>, <em>debug=False</em>, <em>**kwargs</em>)</p>
<p>基类：<code>asyncio.protocols.Protocol</code>此类提供SANIC框架的基本HTTP实现。<code>access_log``app``bail_out</code>(<em>message</em>, <em>from_error=False</em>)如果传输管道关闭，并且SANIC应用程序在向传输管道写入数据时遇到错误，我们会记录错误并提供适当的详细信息。参数<strong>message</strong> (<em>str</em>) – 要显示的错误消息<strong>from_error</strong> (<em>bool</em>) – 如果在处理异常情况时调用了纾困。返回没有<code>cleanup</code>()当使用keepalive特性时调用此函数，它将重置连接，以便能够处理在同一连接上接收另一个请求。<code>close</code>()强制关闭连接。<code>close_if_idle</code>()如果没有发送或接收请求，请关闭连接返回布尔值-关闭时为真，保持打开时为假<code>connection_lost</code>(<em>exc</em>)当连接丢失或关闭时调用。参数是一个异常对象或无（后者意味着接收到一个常规的EOF，或者连接被中止或关闭）。<code>connection_made</code>(<em>transport</em>)在建立连接时调用。参数是表示管道连接的传输。要接收数据，请等待data_received（）调用。当连接关闭时，将调用连接丢失（）。<code>connections``data_received</code>(<em>data</em>)当接收到某些数据时调用。参数是一个字节对象。<code>error_handler``execute_request_handler</code>()调用由 <code>sanic.app.Sanic.handle_request()</code> 方法返回没有<code>expect_handler</code>()Expect头的处理程序。<code>headers``is_request_stream</code><em>property<em><code>keep_alive</code>检查连接是否需要根据附加到 _keep_alive 属性， <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.server.Signal.stopped" target="_blank" rel="noopener"><code>Signal.stopped</code></a> 和 <code>HttpProtocol.parser.should_keep_alive()</code>返回<code>True</code> 如果要保持连接活动 <code>False</code> 其他的<code>keep_alive_timeout``keep_alive_timeout_callback</code>()检查自上次响应以来经过的时间是否超过了我们配置的最大保持活动超时值，如果超过，请关闭传输管道，让响应编写器处理错误。返回没有<code>log_response</code>(</em>response</em>)提供了帮助器方法，以便在 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.server.HttpProtocol.access_log" target="_blank" rel="noopener"><code>HttpProtocol.access_log</code></a> 启用。参数<strong>response</strong> (<a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.response.HTTPResponse" target="_blank" rel="noopener"><code>sanic.response.HTTPResponse</code></a> or <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.response.StreamingHTTPResponse" target="_blank" rel="noopener"><code>sanic.response.StreamingHTTPResponse</code></a>) – 为当前请求生成的响应返回没有<code>loop``on_body</code>(<em>body</em>)<code>on_header</code>(<em>name</em>, <em>value</em>)<code>on_headers_complete</code>()<code>on_message_complete</code>()<code>on_url</code>(<em>url</em>)<code>parser``pause_writing</code>()当传输的缓冲区超过高水位线时调用。pause和resume调用是成对的——当缓冲区严格超过高位标记时（即使后续写入会使缓冲区大小增加更多），调用pause_writing（）一次，当缓冲区大小达到低位标记时，调用resume_writing（）一次。请注意，如果缓冲区大小等于高位标记，则不会调用pause_writing（）——必须严格执行。相反，当缓冲区大小等于或小于低水位线时，将调用resume_writing（）。这些结束条件对于确保当任何一个标记为零时事情按预期进行都很重要。注意：这是唯一一个没有通过eventloop.call_Soon（）调用的协议回调——如果是，它在最需要的时候不会有任何效果（当应用在调用pause_writing（）之前一直在写而不屈服）。<code>request``request_buffer_queue_size``request_class``request_handler``request_max_size``request_timeout``request_timeout_callback</code>()<code>response_timeout``response_timeout_callback</code>()<code>resume_writing</code>()当传输的缓冲区低于低水位线时调用。有关详细信息，请参阅pause_writing（）。<code>router``signal``state``transport``url``write_error</code>(<em>exception</em>)<code>write_response</code>(<em>response</em>)将响应内容同步写入传输。</p>
</li>
<li><p><em>class</em><code>sanic.server.``Signal</code></p>
<p>基类：<code>object``stopped</code><em>= False</em></p>
</li>
<li><p><code>sanic.server.``serve</code>(<em>host</em>, <em>port</em>, <em>app</em>, <em>request_handler</em>, <em>error_handler</em>, <em>before_start=None</em>, <em>after_start=None</em>, <em>before_stop=None</em>, <em>after_stop=None</em>, <em>debug=False</em>, <em>request_timeout=60</em>, <em>response_timeout=60</em>, <em>keep_alive_timeout=5</em>, <em>ssl=None</em>, <em>sock=None</em>, <em>request_max_size=None</em>, <em>request_buffer_queue_size=100</em>, <em>reuse_port=False</em>, <em>loop=None</em>, <em>protocol=&lt;class ‘sanic.server.HttpProtocol’&gt;</em>, <em>backlog=100</em>, <em>register_sys_signals=True</em>, <em>run_multiple=False</em>, <em>run_async=False</em>, <em>connections=None</em>, <em>signal=&lt;sanic.server.Signal object&gt;</em>, <em>request_class=None</em>, <em>access_log=True</em>, <em>keep_alive=True</em>, <em>is_request_stream=False</em>, <em>router=None</em>, <em>websocket_max_size=None</em>, <em>websocket_max_queue=None</em>, <em>websocket_read_limit=65536</em>, <em>websocket_write_limit=65536</em>, <em>state=None</em>, <em>graceful_shutdown_timeout=15.0</em>, <em>asyncio_server_kwargs=None</em>)</p>
<p>在单个进程上启动异步HTTP服务器。参数<strong>host</strong> – 主机地址<strong>port</strong> – 端口到主机上<strong>request_handler</strong> – 带有中间件的SANIC请求处理程序<strong>error_handler</strong> – 带有中间件的SANIC错误处理程序<strong>before_start</strong> – 要在服务器开始侦听之前执行的函数。采取论点 app 实例和 loop<strong>after_start</strong> – 服务器开始侦听后要执行的函数。接受参数 app 实例和 loop<strong>before_stop</strong> – 在执行停止信号之前接收到停止信号时要执行的功能。采取论点 app 实例和 loop<strong>after_stop</strong> – 在收到停止信号后执行的功能。采取论点 app 实例和 loop<strong>debug</strong> – 启用调试输出（减慢服务器速度）<strong>request_timeout</strong> – 秒秒时间<strong>response_timeout</strong> – 秒秒时间<strong>keep_alive_timeout</strong> – 秒秒时间<strong>ssl</strong> – SSLContext<strong>sock</strong> – 服务器接受连接的套接字<strong>request_max_size</strong> – 字节大小， None 无限制<strong>reuse_port</strong> – True 对于多个工人<strong>loop</strong> – 异步兼容事件循环<strong>protocol</strong> – Asyncio协议类的子类<strong>request_class</strong> – 请求类使用<strong>access_log</strong> – 禁用/启用访问日志<strong>websocket_max_size</strong> – 强制传入消息的最大大小（字节）。<strong>websocket_max_queue</strong> – 设置保存传入消息的队列的最大长度。<strong>websocket_read_limit</strong> – 为输入字节设置缓冲区的上限，下限是上限的一半。<strong>websocket_write_limit</strong> – 为输出字节设置缓冲区的上限，下限是上限的四分之一。<strong>is_request_stream</strong> – 禁用/启用request.stream<strong>request_buffer_queue_size</strong> – 流请求缓冲区队列大小<strong>router</strong> – 路由器对象<strong>graceful_shutdown_timeout</strong> – 强制关闭非空闲连接需要多长时间<strong>asyncio_server_kwargs</strong> – asyncio/uvloop create_server方法的键值参数返回没有什么</p>
</li>
<li><p><code>sanic.server.``serve_multiple</code>(<em>server_settings</em>, <em>workers</em>)</p>
<p>同时启动多个服务器进程。在中断和终止信号时停止，并在完成时排出连接。参数<strong>server_settings</strong> – 要传递给serve函数的kw参数<strong>workers</strong> – 要启动的工人数<strong>stop_event</strong> – 如果提供，用作停止信号返回</p>
</li>
<li><p><code>sanic.server.``trigger_events</code>(<em>events</em>, <em>loop</em>)</p>
<p>触发器事件回调（函数或异步）参数<strong>events</strong> – 要执行的一个或多个同步或异步函数<strong>loop</strong> – 事件循环</p>
</li>
</ul>
<h2 id="静态模块"><a href="#静态模块" class="headerlink" title="静态模块"></a>静态模块</h2><ul>
<li><p><code>sanic.static.``register</code>(<em>app</em>, <em>uri</em>, <em>file_or_directory</em>, <em>pattern</em>, <em>use_modified_since</em>, <em>use_content_range</em>, <em>stream_large_files</em>, <em>name=’static’</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>content_type=None</em>)</p>
<p>通过向路由器添加路由并注册处理程序，向SANIC注册静态目录处理程序。参数<strong>app</strong> – Sanic<strong>file_or_directory</strong> – 提供服务的文件或目录路径<strong>uri</strong> – 提供服务的URL<strong>pattern</strong> – 用于匹配URL中文件的正则表达式<strong>use_modified_since</strong> – 如果为真，则发送文件修改时间，如果浏览器与服务器匹配，则返回“未修改”。<strong>use_content_range</strong> – 如果为真，则处理范围请求的头并发送请求的文件部分<strong>stream_large_files</strong> – 如果为真，则使用文件流（）处理程序而不是文件（）处理程序发送文件。如果这是一个整数，则表示要切换到文件流（）的阈值大小。<strong>name</strong> – 用于URL的用户定义名称<strong>content_type</strong> – 标题的用户定义内容类型</p>
</li>
</ul>
<h2 id="sanic-测试模块"><a href="#sanic-测试模块" class="headerlink" title="sanic.测试模块"></a>sanic.测试模块</h2><ul>
<li><p><em>class<em><code>sanic.testing.``SanicASGIAdapter</code>(</em>app</em>, <em>suppress_exceptions: bool = False</em>)</p>
<p>基类：<code>requests_async.asgi.ASGIAdapter</code></p>
</li>
<li><p><em>class<em><code>sanic.testing.``SanicASGITestClient</code>(</em>app</em>, <em>base_url: str = ‘<a href="http://mockserver&#39;" target="_blank" rel="noopener">http://mockserver&#39;</a></em>, <em>suppress_exceptions: bool = False</em>)</p>
<p>基类：<code>requests_async.asgi.ASGISession``merge_environment_settings</code>(<strong>args*, *</strong>kwargs*)检查环境并将其与某些设置合并。返回类型dict</p>
</li>
<li><p><em>class<em><code>sanic.testing.``SanicTestClient</code>(</em>app</em>, <em>port=42101</em>)</p>
<p>基类：<code>object``delete</code>(<strong>args*, *</strong>kwargs<em>)<code>get</code>(**args</em>, <strong><em>kwargs</em>)<code>get_new_session</code>()<code>head</code>(</strong>args<em>, ***kwargs</em>)<code>options</code>(<strong>args*, *</strong>kwargs<em>)<code>patch</code>(**args</em>, <strong><em>kwargs</em>)<code>post</code>(</strong>args<em>, ***kwargs</em>)<code>put</code>(<strong>args*, *</strong>kwargs<em>)<code>websocket</code>(**args</em>, <em>**kwargs</em>)</p>
</li>
<li><p><em>class</em><code>sanic.testing.``TestASGIApp</code></p>
<p>基类：<code>sanic.asgi.ASGIApp</code></p>
</li>
</ul>
<h2 id="sanic-views模块"><a href="#sanic-views模块" class="headerlink" title="sanic.views模块"></a>sanic.views模块</h2><ul>
<li><p><em>class</em><code>sanic.views.``CompositionView</code></p>
<p>基类：<code>object</code>SANIC的简单方法函数映射视图。您可以为您想要支持的每个HTTP方法向方法（get、post、put、patch、delete）添加处理程序函数。例如：view=compositionview（）视图。添加（ [“得到”] ，lambda请求：text（“I am get method”））视图。添加（ [“邮”、“放”] ，lambda请求：text（“我是post/put方法”））等。如果有人试图使用一个未实现的方法，将会有405个响应。<code>add</code>(<em>methods</em>, <em>handler</em>, <em>stream=False</em>)</p>
</li>
<li><p><em>class</em><code>sanic.views.``HTTPMethodView</code></p>
<p>基类：<code>object</code>SANIC视图的简单基于类的实现。您应该为您想要支持的每个HTTP方法实现类的方法（get、post、put、patch、delete）。例如：<code>class DummyView(HTTPMethodView):     def get(self, request, *args, **kwargs):         return text(&#39;I am get method&#39;)     def put(self, request, *args, **kwargs):         return text(&#39;I am put method&#39;)</code>等。如果有人试图使用一个未实现的方法，将会有405个响应。如果需要任何URL参数，只需在方法定义中提到它们：<code>class DummyView(HTTPMethodView):     def get(self, request, my_param_here, *args, **kwargs):         return text(&#39;I am get method with %s&#39; % my_param_here)</code>要将视图添加到路由中，可以使用app.add_route（dummyview.as_view（），’/‘）app.route（“/”）（dummyView.as_View（））要添加任何decorator，可以将其设置为decorators变量<em>classmethod<em><code>as_view</code>(*</em>class_args</em>, <strong><em>class_kwargs</em>)用于路由系统的返回视图函数，该函数将请求发送到适当的处理程序方法。<code>decorators</code><em>= []<em><code>dispatch_request</code>(</em>request</em>, <em>*args</em>, *</strong>kwargs*)</p>
</li>
<li><p><code>sanic.views.``stream</code>(<em>func</em>)</p>
</li>
</ul>
<h2 id="sanic-websocket模块"><a href="#sanic-websocket模块" class="headerlink" title="sanic.websocket模块"></a>sanic.websocket模块</h2><ul>
<li><p><em>class<em><code>sanic.websocket.``WebSocketConnection</code>(</em>send: Callable[[MutableMapping[str, Any]], Awaitable[None]], receive: Callable[[], Awaitable[MutableMapping[str, Any]]]</em>)</p>
<p>基类：<code>object</code></p>
</li>
<li><p><em>class<em><code>sanic.websocket.``WebSocketProtocol</code>(*</em>args</em>, <em>websocket_timeout=10</em>, <em>websocket_max_size=None</em>, <em>websocket_max_queue=None</em>, <em>websocket_read_limit=65536</em>, <em>websocket_write_limit=65536</em>, <em>**kwargs</em>)</p>
<p>基类：<a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.server.HttpProtocol" target="_blank" rel="noopener"><code>sanic.server.HttpProtocol</code></a><code>access_log``app``connection_lost</code>(<em>exc</em>)当连接丢失或关闭时调用。参数是一个异常对象或无（后者意味着接收到一个常规的EOF，或者连接被中止或关闭）。<code>connections``data_received</code>(<em>data</em>)当接收到某些数据时调用。参数是一个字节对象。<code>error_handler``headers``is_request_stream``keep_alive_timeout``keep_alive_timeout_callback</code>()检查自上次响应以来经过的时间是否超过了我们配置的最大保持活动超时值，如果超过，请关闭传输管道，让响应编写器处理错误。返回没有<code>loop``parser``request``request_buffer_queue_size``request_class``request_handler``request_max_size``request_timeout``request_timeout_callback</code>()<code>response_timeout``response_timeout_callback</code>()<code>router``signal``state``transport``url``write_response</code>(<em>response</em>)将响应内容同步写入传输。</p>
</li>
</ul>
<h2 id="sanic-worker模块"><a href="#sanic-worker模块" class="headerlink" title="sanic.worker模块"></a>sanic.worker模块</h2><h2 id="模块内容"><a href="#模块内容" class="headerlink" title="模块内容"></a>模块内容</h2><ul>
<li><p><em>class<em><code>sanic.``Sanic</code>(</em>name=None</em>, <em>router=None</em>, <em>error_handler=None</em>, <em>load_env=True</em>, <em>request_class=None</em>, <em>strict_slashes=False</em>, <em>log_config=None</em>, <em>configure_logging=True</em>)</p>
<p>基类：<code>object``add_route</code>(<em>handler</em>, <em>uri</em>, <em>methods=frozenset({‘GET’})</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>version=None</em>, <em>name=None</em>, <em>stream=False</em>)将类实例或函数注册为应用程序URL路由的处理程序的帮助器方法。参数<strong>handler</strong> – 函数或类实例<strong>uri</strong> – URL路径<strong>methods</strong> – 允许的方法列表或元组，如果使用httpmethodview，则会重写这些方法<strong>host</strong> –<strong>strict_slashes</strong> –<strong>version</strong> –<strong>name</strong> – URL的用户定义路由名称<strong>stream</strong> – 布尔值，指定处理程序是否为流处理程序返回函数或类实例<code>add_task</code>(<em>task</em>)在循环开始后，安排任务稍后运行。与asyncio.secure-future不同的是，它也不会返回未来，实际的secure-future调用会延迟到服务器启动之前。参数<strong>task</strong> – 未来、古鲁特或等待<code>add_websocket_route</code>(<em>handler</em>, <em>uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>subprotocols=None</em>, <em>name=None</em>)将函数注册为WebSocket路由的帮助器方法。参数<strong>handler</strong> – 可以处理WebSocket请求的类的可调用函数或实例<strong>host</strong> – 主机IP或FQDN详细信息<strong>uri</strong> – 将映射到WebSocket处理程序的URL路径<strong>strict_slashes</strong> – 如果API端点需要以“/”终止或不终止<strong>subprotocols</strong> – 用于WebSocket握手的子协议<strong>name</strong> – 为该URL分配的唯一名称，以便它可以与 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.Sanic.url_for" target="_blank" rel="noopener"><code>url_for()</code></a>返回反对者装饰者 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#module-sanic.websocket" target="_blank" rel="noopener"><code>websocket()</code></a><em>property<em><code>asgi_client``blueprint</code>(</em>blueprint</em>, <strong><em>options</em>)在应用程序上注册蓝图。参数</strong>blueprint<em>* – 蓝图对象或其（列表、元组）<strong>options</strong> – 带蓝图默认值的选项字典返回没有什么<code>converted_response_type</code>(*response</em>)未提供实现。<code>delete</code>(<em>uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>version=None</em>, <em>name=None</em>)在下添加API URL <strong>DELETE</strong> <em>HTTP</em> 方法参数<strong>uri</strong> – 要标记到的URL <strong>DELETE</strong> 方法 <em>HTTP<strong>*host</strong> – 要使用的服务的主机IP或FQDN<strong>strict_slashes</strong> – 指导 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.Sanic" target="_blank" rel="noopener"><code>Sanic</code></a> 检查请求URL是否需要使用 <em>/**</em>version** – API版本<strong>name</strong> – 可用于标识路由的唯一名称返回具有 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.Sanic.route" target="_blank" rel="noopener"><code>route()</code></a> 方法 的对象装饰器<code>enable_websocket</code>(*enable=True</em>)启用或禁用对WebSocket的支持。如果将WebSocket路由添加到应用程序，则会自动启用WebSocket。<code>exception</code>(<strong>exceptions*)修饰要注册为异常处理程序的函数参数</strong>exceptions<em>* – 例外返回装饰功能<code>get</code>(*uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>version=None</em>, <em>name=None</em>)在下添加API URL <strong>GET</strong> <em>HTTP</em> 方法参数<strong>uri</strong> – 要标记到的URL <strong>GET</strong> 方法 <em>HTTP<strong>*host</strong> – 要使用的服务的主机IP或FQDN<strong>strict_slashes</strong> – 指导 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.Sanic" target="_blank" rel="noopener"><code>Sanic</code></a> 检查请求URL是否需要使用 <em>/**</em>version** – API版本<strong>name</strong> – 可用于标识路由的唯一名称返回具有 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.Sanic.route" target="_blank" rel="noopener"><code>route()</code></a> 方法 的对象装饰器<code>head</code>(*uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>version=None</em>, <em>name=None</em>)<code>listener</code>(<em>event</em>)从修饰函数创建侦听器。参数<strong>event</strong> – 要收听的事件<em>property<em><code>loop</code>与asyncio.get_event_loop（）同义。仅在使用时支持 app.run 方法。<code>middleware</code>(</em>middleware_or_request</em>)装饰和注册在请求之前调用的中间件。可以调用为 <em>@app.middleware</em> 或 <em>@应用中间件（请求）<em>Param中间件请求：用于标识正在注册的中间件类型的可选参数。<code>options</code>(</em>uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>version=None</em>, <em>name=None</em>)在下添加API URL <strong>OPTIONS</strong> <em>HTTP</em> 方法参数<strong>uri</strong> – 要标记到的URL <strong>OPTIONS</strong> 方法 <em>HTTP<strong>*host</strong> – 要使用的服务的主机IP或FQDN<strong>strict_slashes</strong> – 指导 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.Sanic" target="_blank" rel="noopener"><code>Sanic</code></a> 检查请求URL是否需要使用 <em>/**</em>version** – API版本<strong>name</strong> – 可用于标识路由的唯一名称返回具有 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.Sanic.route" target="_blank" rel="noopener"><code>route()</code></a> 方法 的对象装饰器<code>patch</code>(*uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>stream=False</em>, <em>version=None</em>, <em>name=None</em>)在下添加API URL <strong>PATCH</strong> <em>HTTP</em> 方法参数<strong>uri</strong> – 要标记到的URL <strong>PATCH</strong> 方法 <em>HTTP<strong>*host</strong> – 要使用的服务的主机IP或FQDN<strong>strict_slashes</strong> – 指导 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.Sanic" target="_blank" rel="noopener"><code>Sanic</code></a> 检查请求URL是否需要使用 <em>/**</em>version** – API版本<strong>name</strong> – 可用于标识路由的唯一名称返回具有 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.Sanic.route" target="_blank" rel="noopener"><code>route()</code></a> 方法 的对象装饰器<code>post</code>(*uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>stream=False</em>, <em>version=None</em>, <em>name=None</em>)在下添加API URL <strong>POST</strong> <em>HTTP</em> 方法参数<strong>uri</strong> – 要标记到的URL <strong>POST</strong> 方法 <em>HTTP<strong>*host</strong> – 要使用的服务的主机IP或FQDN<strong>strict_slashes</strong> – 指导 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.Sanic" target="_blank" rel="noopener"><code>Sanic</code></a> 检查请求URL是否需要使用 <em>/**</em>version** – API版本<strong>name</strong> – 可用于标识路由的唯一名称返回具有 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.Sanic.route" target="_blank" rel="noopener"><code>route()</code></a> 方法 的对象装饰器<code>put</code>(*uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>stream=False</em>, <em>version=None</em>, <em>name=None</em>)在下添加API URL <strong>PUT</strong> <em>HTTP</em> 方法参数<strong>uri</strong> – 要标记到的URL <strong>PUT</strong> 方法 <em>HTTP<strong>*host</strong> – 要使用的服务的主机IP或FQDN<strong>strict_slashes</strong> – 指导 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.Sanic" target="_blank" rel="noopener"><code>Sanic</code></a> 检查请求URL是否需要使用 <em>/**</em>version** – API版本<strong>name</strong> – 可用于标识路由的唯一名称返回具有 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.Sanic.route" target="_blank" rel="noopener"><code>route()</code></a> 方法 的对象装饰器<code>register_blueprint</code>(**args</em>, <strong><em>kwargs</em>)为调用 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.Sanic.blueprint" target="_blank" rel="noopener"><code>blueprint()</code></a> 方法注解在1.0中被弃用。使用 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.Sanic.blueprint" target="_blank" rel="noopener"><code>blueprint()</code></a> 相反。参数</strong>args<em>* – 蓝图对象或其（列表、元组）<strong>kwargs</strong> – 带蓝图默认值的选项字典返回没有<code>register_listener</code>(*listener</em>, <em>event</em>)注册给定事件的侦听器。ARG:listener:callable，即setup_db（app，loop）event：何时注册listener，即’before_server_start’返回：侦听器<code>register_middleware</code>(<em>middleware</em>, <em>attach_to=’request’</em>)注册一个应用程序级中间件，该中间件将附加到此应用程序下注册的所有API URL。此方法由 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.Sanic.middleware" target="_blank" rel="noopener"><code>middleware()</code></a> 在应用程序级别提供的装饰器。参数<strong>middleware</strong> – 要附加到中间件的回调方法<strong>attach_to</strong> – 在中间件的生命周期中需要调用中间件的状态 <em>HTTP请求</em> . <strong>请求</strong> -在处理请求之前调用 <strong>响应</strong> -在返回响应之前调用返回装饰器方法<code>remove_route</code>(<em>uri</em>, <em>clean_cache=True</em>, <em>host=None</em>)此方法为应用程序用户提供了一种机制，通过该机制可以从 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.Sanic" target="_blank" rel="noopener"><code>Sanic</code></a> 对象警告删除路由在V19.06中已弃用，将从未来版本中删除。参数<strong>uri</strong> – 要从应用程序中删除的URL路径<strong>clean_cache</strong> – 如果需要清理LRU路由缓存，则指示SANIC<strong>host</strong> – 特定于主机的IP地址或FQDN返回没有<code>route</code>(<em>uri</em>, <em>methods=frozenset({‘GET’})</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>stream=False</em>, <em>version=None</em>, <em>name=None</em>)修饰要注册为路由的函数参数<strong>uri</strong> – URL路径<strong>methods</strong> – 允许的方法列表或元组<strong>host</strong> –<strong>strict_slashes</strong> –<strong>stream</strong> –<strong>version</strong> –<strong>name</strong> – URL的用户定义路由名称返回装饰功能<code>run</code>(<em>host: Optional[str] = None</em>, <em>port: Optional[int] = None</em>, <em>debug: bool = False</em>, <em>ssl: Union[dict</em>, <em>ssl.SSLContext</em>, <em>None] = None</em>, <em>sock: Optional[socket.socket] = None</em>, <em>workers: int = 1</em>, <em>protocol: Type[asyncio.protocols.Protocol] = None</em>, <em>backlog: int = 100</em>, <em>stop_event: Any = None</em>, <em>register_sys_signals: bool = True</em>, <em>access_log: Optional[bool] = None</em>, <strong><em>kwargs</em>) → None运行HTTP服务器并监听，直到键盘中断或终端信号。在终端上，在关闭之前排空连接。参数</strong>host<em>* (*str</em>) – 主机地址<strong>port</strong> (<em>int</em>) – 端口到主机上<strong>debug</strong> (<em>bool</em>) – 启用调试输出（减慢服务器速度）<strong>ssl</strong> – sslcontext，或工作进程的ssl加密的证书和密钥的位置：键入ssl:sslcontext或dict:param sock:socket，以便服务器接受来自以下对象的连接：type sock:socket:param workers:在遵守之前接收的进程数：type workers:int:param protocol:asyncio协议的子类：type protocol:type [协议] ：param backlog：系统未接受的连接数。在拒绝新连接之前允许参数<strong>stop_event</strong> (<em>None</em>) – 停止应用程序前要触发的事件-已弃用<strong>register_sys_signals</strong> (<em>bool</em>) – 注册 SIG* 事件<strong>access_log</strong> (<em>bool</em>) – 允许写入访问日志（减慢服务器速度）返回没有什么<code>static</code>(<em>uri</em>, <em>file_or_directory</em>, <em>pattern=’/?.+’</em>, <em>use_modified_since=True</em>, <em>use_content_range=False</em>, <em>stream_large_files=False</em>, <em>name=’static’</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>content_type=None</em>)注册根目录以从中提供文件。输入可以是文件或目录。此方法将使设置 <code>Route</code> 服务静态文件所必需的。参数<strong>uri</strong> – 用于服务静态内容的URL路径<strong>file_or_directory</strong> – 包含静态文件的静态文件/目录的路径<strong>pattern</strong> – 识别有效静态文件的regex模式<strong>use_modified_since</strong> – 如果为真，则发送文件修改时间，如果浏览器与服务器匹配，则返回“未修改”。<strong>use_content_range</strong> – 如果为真，则处理范围请求的头并发送请求的文件部分<strong>stream_large_files</strong> – 如果为真，请使用 <code>StreamingHTTPResponse.file_stream()</code> 处理程序而不是 <code>HTTPResponse.file()</code> 用于发送文件的处理程序。如果这是一个整数，则表示要切换到的阈值大小 <code>StreamingHTTPResponse.file_stream()</code><strong>name</strong> – 用于URL的用户定义名称<strong>host</strong> – 要使用的服务的主机IP或FQDN<strong>strict_slashes</strong> – 指导 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.Sanic" target="_blank" rel="noopener"><code>Sanic</code></a> 检查请求URL是否需要使用 <em>/<strong>*content_type</strong> – 标题的用户定义内容类型返回没有<code>stop</code>()这会杀死 Sanic<em>property</em><code>test_client``url_for</code>(*view_name: str</em>, <strong><em>kwargs</em>)基于视图名称和提供的值生成URL。为了构建URL，必须将所有请求参数作为关键字参数提供，并且每个参数必须通过指定参数类型的测试。如果不满足这些条件，a URLBuildError 将被抛出。不是请求参数的关键字参数将包含在输出URL的查询字符串中。参数</strong>view_name<em>* – 引用视图名称的字符串<strong><em>\</em>kwargs</strong> – 用于生成请求参数和查询字符串参数的键和值。返回内置URL产生：URLBuildError<code>websocket</code>(*uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>subprotocols=None</em>, <em>name=None</em>)修饰要注册为WebSocket路由的函数：param uri:url的路径：param host:host ip或fqdn详细信息：param strict_slashes:如果API端点需要终止是否带有“/”参数<strong>subprotocols</strong> – 具有支持的子协议的str的可选列表<strong>name</strong> – 为该URL分配的唯一名称，以便它可以与 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.Sanic.url_for" target="_blank" rel="noopener"><code>url_for()</code></a>返回装饰功能</p>
</li>
<li><p><em>class<em><code>sanic.``Blueprint</code>(</em>name</em>, <em>url_prefix=None</em>, <em>host=None</em>, <em>version=None</em>, <em>strict_slashes=None</em>)</p>
<p>基类：<code>object``add_route</code>(<em>handler</em>, <em>uri</em>, <em>methods=frozenset({‘GET’})</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>version=None</em>, <em>name=None</em>, <em>stream=False</em>)从函数创建蓝图路由。参数<strong>handler</strong> – 用于处理URI请求的函数。接受带有视图类方法的函数或类实例。<strong>uri</strong> – 路由可访问的终结点。<strong>methods</strong> – 可接受的HTTP方法列表。<strong>host</strong> – 要使用的SANIC服务器的FQDN的IP地址。<strong>strict_slashes</strong> – 强制通过培训请求API URL <em>/<strong>*version</strong> – 蓝图版本<strong>name</strong> – URL的用户定义路由名称<strong>stream</strong> – 布尔值，指定处理程序是否为流处理程序返回函数或类实例<code>add_websocket_route</code>(*handler</em>, <em>uri</em>, <em>host=None</em>, <em>version=None</em>, <em>name=None</em>)从函数创建蓝图WebSocket路由。参数<strong>handler</strong> – 用于处理URI请求的函数。接受带有视图类方法的函数或类实例。<strong>uri</strong> – 路由可访问的终结点。<strong>host</strong> – 要使用的SANIC服务器的FQDN的IP地址。<strong>version</strong> – 蓝图版本<strong>name</strong> – 用于标识WebSocket路由的唯一名称返回函数或类实例<code>delete</code>(<em>uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>version=None</em>, <em>name=None</em>)在下添加API URL <strong>DELETE</strong> <em>HTTP</em> 方法参数<strong>uri</strong> – 要标记到的URL <strong>DELETE</strong> 方法 <em>HTTP<strong>*host</strong> – 要使用的服务的主机IP或FQDN<strong>strict_slashes</strong> – 指导 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic" target="_blank" rel="noopener"><code>sanic.app.Sanic</code></a> 检查请求URL是否需要使用 <em>/**</em>version** – API版本<strong>name</strong> – 可用于标识路由的唯一名称返回具有 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.Blueprint.route" target="_blank" rel="noopener"><code>route()</code></a> 方法 的对象装饰器<code>exception</code>(**args</em>, <strong><em>kwargs</em>)此方法允许为有问题的当前蓝图创建全局异常处理程序。参数</strong>args<em>* – 处理程序要捕获的python异常列表<strong>kwargs</strong> – 要传递给异常处理程序的其他可选参数：返回修饰方法以处理任何在此蓝图下注册的路线。<code>get</code>(*uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>version=None</em>, <em>name=None</em>)在下添加API URL <strong>GET</strong> <em>HTTP</em> 方法参数<strong>uri</strong> – 要标记到的URL <strong>GET</strong> 方法 <em>HTTP<strong>*host</strong> – 要使用的服务的主机IP或FQDN<strong>strict_slashes</strong> – 指导 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic" target="_blank" rel="noopener"><code>sanic.app.Sanic</code></a> 检查请求URL是否需要使用 <em>/**</em>version** – API版本<strong>name</strong> – 可用于标识路由的唯一名称返回具有 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.Blueprint.route" target="_blank" rel="noopener"><code>route()</code></a> 方法 的对象装饰器<em>static</em><code>group</code>(**blueprints</em>, <em>url_prefix=’’</em>)创建一个蓝图列表，可以选择在通用URL前缀下对其进行分组。参数<strong>blueprints</strong> – 要注册为组的蓝图<strong>url_prefix</strong> – 所有子前缀的URL路由<code>head</code>(<em>uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>version=None</em>, <em>name=None</em>)在下添加API URL <strong>HEAD</strong> <em>HTTP</em> 方法参数<strong>uri</strong> – 要标记到的URL <strong>HEAD</strong> 方法 <em>HTTP<strong>*host</strong> – 要使用的服务的主机IP或FQDN<strong>strict_slashes</strong> – 指导 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic" target="_blank" rel="noopener"><code>sanic.app.Sanic</code></a> 检查请求URL是否需要使用 <em>/**</em>version** – API版本<strong>name</strong> – 可用于标识路由的唯一名称返回具有 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.Blueprint.route" target="_blank" rel="noopener"><code>route()</code></a> 方法 的对象装饰器<code>listener</code>(*event</em>)从修饰函数创建侦听器。参数<strong>event</strong> – 要收听的事件。<code>middleware</code>(<strong>args*, *</strong>kwargs<em>)从修饰函数创建蓝图中间件。参数<strong>args</strong> – 调用中间件时要使用的位置参数<strong>kwargs</strong> – 可用于中间件的可选关键字参数。<code>options</code>(*uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>version=None</em>, <em>name=None</em>)在下添加API URL <strong>OPTIONS</strong> <em>HTTP</em> 方法参数<strong>uri</strong> – 要标记到的URL <strong>OPTIONS</strong> 方法 <em>HTTP<strong>*host</strong> – 要使用的服务的主机IP或FQDN<strong>strict_slashes</strong> – 指导 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic" target="_blank" rel="noopener"><code>sanic.app.Sanic</code></a> 检查请求URL是否需要使用 <em>/**</em>version** – API版本<strong>name</strong> – 可用于标识路由的唯一名称返回具有 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.Blueprint.route" target="_blank" rel="noopener"><code>route()</code></a> 方法 的对象装饰器<code>patch</code>(*uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>stream=False</em>, <em>version=None</em>, <em>name=None</em>)在下添加API URL <strong>PATCH</strong> <em>HTTP</em> 方法参数<strong>uri</strong> – 要标记到的URL <strong>PATCH</strong> 方法 <em>HTTP<strong>*host</strong> – 要使用的服务的主机IP或FQDN<strong>strict_slashes</strong> – 指导 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic" target="_blank" rel="noopener"><code>sanic.app.Sanic</code></a> 检查请求URL是否需要使用 <em>/**</em>version** – API版本<strong>name</strong> – 可用于标识路由的唯一名称返回具有 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.Blueprint.route" target="_blank" rel="noopener"><code>route()</code></a> 方法 的对象装饰器<code>post</code>(*uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>stream=False</em>, <em>version=None</em>, <em>name=None</em>)在下添加API URL <strong>POST</strong> <em>HTTP</em> 方法参数<strong>uri</strong> – 要标记到的URL <strong>POST</strong> 方法 <em>HTTP<strong>*host</strong> – 要使用的服务的主机IP或FQDN<strong>strict_slashes</strong> – 指导 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic" target="_blank" rel="noopener"><code>sanic.app.Sanic</code></a> 检查请求URL是否需要使用 <em>/**</em>version** – API版本<strong>name</strong> – 可用于标识路由的唯一名称返回具有 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.Blueprint.route" target="_blank" rel="noopener"><code>route()</code></a> 方法 的对象装饰器<code>put</code>(*uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>stream=False</em>, <em>version=None</em>, <em>name=None</em>)在下添加API URL <strong>PUT</strong> <em>HTTP</em> 方法参数<strong>uri</strong> – 要标记到的URL <strong>PUT</strong> 方法 <em>HTTP<strong>*host</strong> – 要使用的服务的主机IP或FQDN<strong>strict_slashes</strong> – 指导 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic" target="_blank" rel="noopener"><code>sanic.app.Sanic</code></a> 检查请求URL是否需要使用 <em>/**</em>version** – API版本<strong>name</strong> – 可用于标识路由的唯一名称返回具有 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.Blueprint.route" target="_blank" rel="noopener"><code>route()</code></a> 方法 的对象装饰器<code>register</code>(*app</em>, <em>options</em>)将蓝图注册到sanic应用程序。参数<strong>app</strong> – 实例 <a href="https://www.osgeo.cn/sanic/sanic/api_reference.html#sanic.app.Sanic" target="_blank" rel="noopener"><code>sanic.app.Sanic</code></a> 班<strong>options</strong> – 将蓝图注册到应用程序时要使用的选项。 <em>url_prefix</em> -覆盖蓝图前缀的URL前缀<code>route</code>(<em>uri</em>, <em>methods=frozenset({‘GET’})</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>stream=False</em>, <em>version=None</em>, <em>name=None</em>)从修饰函数创建蓝图路由。参数<strong>uri</strong> – 路由可访问的终结点。<strong>methods</strong> – 可接受的HTTP方法列表。<strong>host</strong> – 要使用的SANIC服务器的FQDN的IP地址。<strong>strict_slashes</strong> – 强制通过培训请求API URL <em>/<strong>*stream</strong> – 如果路由应该提供流支持<strong>version</strong> – 蓝图版本<strong>name</strong> – 用于标识路由的唯一名称：返回一个修饰方法，调用该方法时将返回一个对象类型的 <code>FutureRoute``static</code>(*uri</em>, <em>file_or_directory</em>, <strong>args*, *</strong>kwargs<em>)从修饰函数创建蓝图静态路由。参数<strong>uri</strong> – 路由可访问的终结点。<strong>file_or_directory</strong> – 静态资产。<code>websocket</code>(*uri</em>, <em>host=None</em>, <em>strict_slashes=None</em>, <em>version=None</em>, <em>name=None</em>)从修饰函数创建蓝图WebSocket路由。参数<strong>uri</strong> – 路由可访问的终结点。<strong>host</strong> – 要使用的SANIC服务器的FQDN的IP地址。<strong>strict_slashes</strong> – 强制通过培训请求API URL <em>/**</em>version** – 蓝图版本<strong>name</strong> – 用于标识WebSocket路由的唯一名称</p>
</li>
</ul>
<h1 id="python-3-7异步示例"><a href="#python-3-7异步示例" class="headerlink" title="python 3.7异步示例"></a>python 3.7异步示例</h1><p>使用python 3.7，asyncio获得了以下类型的主要更新：</p>
<blockquote>
<ul>
<li>asyncio.AbstractEventLoop</li>
<li>asyncio.AbstractServer</li>
</ul>
</blockquote>
<p>这个示例演示了如何将SANIC与Python3.7结合使用，更准确地说：如何检索Asyncio服务器实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">import socket</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">from sanic import Sanic</span><br><span class="line">from sanic.response import json</span><br><span class="line"></span><br><span class="line">app = Sanic(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&quot;)</span><br><span class="line">async def test(request):</span><br><span class="line">    return json(&#123;&quot;hello&quot;: &quot;world&quot;&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server_socket = &apos;/tmp/sanic.sock&apos;</span><br><span class="line"></span><br><span class="line">sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    os.remove(server_socket)</span><br><span class="line">finally:</span><br><span class="line">    sock.bind(server_socket)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    srv_coro = app.create_server(</span><br><span class="line">        sock=sock,</span><br><span class="line">        return_asyncio_server=True,</span><br><span class="line">        asyncio_server_kwargs=dict(</span><br><span class="line">            start_serving=False</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line">    srv = loop.run_until_complete(srv_coro)</span><br><span class="line">    try:</span><br><span class="line">        assert srv.is_serving() is False</span><br><span class="line">        loop.run_until_complete(srv.start_serving())</span><br><span class="line">        assert srv.is_serving() is True</span><br><span class="line">        loop.run_until_complete(srv.serve_forever())</span><br><span class="line">    except KeyboardInterrupt:</span><br><span class="line">        srv.close()</span><br><span class="line">        loop.close()</span><br></pre></td></tr></table></figure>

<p>请注意，uvloop还不支持这些功能。</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>ww</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://yoursite.com/2019/09/09/sanic安装/">http://yoursite.com/2019/09/09/sanic安装/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span></span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>good good stady</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Python/"># Python</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2019/09/12/3容器操作命令/">docker容器操作命令</a>
            
            
            <a class="next" rel="next" href="/2019/09/09/hello-world/">Hello World</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© ww | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
