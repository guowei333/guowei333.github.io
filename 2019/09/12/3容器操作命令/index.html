<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">



<title>docker容器操作命令 | </title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">ww</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">帖子</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">简历</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">ww</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">帖子</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">简历</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">docker容器操作命令</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">ww</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">九月 12, 2019&nbsp;&nbsp;17:08:28</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <p><strong>容器</strong>是docker的另一个核心概念，简单来说，容器是镜像的一个运行实例所不同的是，镜像是静态的只读文件，而容器带有运行时需要的可写文件层，同时，容器中的应用进程处于运行状态。</p>
<p>如果认为虚拟机是模拟运行的一整套操作系统（包括内核、应用运行态环境和其他系统环境）和跑在上面的应用。那么docker容器就是独立运行的一个（或一组）应用。以及他们必需的运行环境</p>
<p>具体介绍围绕容器的重要操作，包括创建一个容器、启动容器、终止一个容器、进入容器内执行操作、删除容器和通过导入导出容器来实现容器迁移等</p>
<h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><p>从现在开始，忘掉“朦肿”的虚拟机吧，对容器的操作就像直接操作应用一样简单和 快速。 </p>
<p>本节主要介绍 Docker 容器的 create、 start、 run, wait 和 logs 子命令。</p>
<p><strong>新建容器</strong></p>
<p>可以使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] create</span><br></pre></td></tr></table></figure>

<p>命令新建一个容器。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker create -it ubuntu:latest </span><br><span class="line"></span><br><span class="line">$ docker ps -a</span><br></pre></td></tr></table></figure>

<p>使用docker [container] create 命令新建的容器处于停止状态，可以使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] start</span><br></pre></td></tr></table></figure>

<p>来启动它</p>
<p>由于容器整个Docker技术栈的核心，create命令和后续的run命令支持的选项都十分复杂</p>
<p>选项主要包括如下几大类 ： <strong>与容器运行模式相关</strong>、<strong>与容器环境配置相关</strong>、<strong>与容器资源限制</strong>和<strong>安全保护</strong>相关，参见表 4-1～表 4-3。</p>
<h5 id><a href="#" class="headerlink" title=" "></a> </h5><h5 id="create-命令与容器运行模式相关的选项"><a href="#create-命令与容器运行模式相关的选项" class="headerlink" title="create 命令与容器运行模式相关的选项"></a>create 命令与容器运行模式相关的选项</h5><table>
    <tr>
        <td>选项</td>
        <td>说明</td>
    </tr>
    <tr>
        <td>-a, --attach=[ ]</td>
        <td>是否绑定到标准输入、输出和错误 </td>
    </tr>
    <tr>
        <td>-d，…detach=true | false</td>
        <td>是否在后台运行容器，默认为否  </td>
    </tr>
    <tr>
        <td>--detach-keys=””</td>
        <td>从 attach 模式退出的快捷键 </td>
    </tr>
    <tr>
        <td>--entrypoint="”</td>
        <td>镜像存在入口命令时，覆盖为新的命令  </td>
    </tr>
    <tr>
        <td>--expose=[ ]</td>
        <td>指定容器会暴露出来的端口或端口范围  </td>
    </tr>
    <tr>
        <td>--group-add=[ ]</td>
        <td>运行容器的用户组  </td>
    </tr>
    <tr>
        <td>- i, --interactive=true | false </td>
        <td>保持标准输入打开，默认为 false  </td>
    </tr>
    <tr>
        <td>--ipc = “”</td>
        <td>容器 lPC 命名空间，可以为其他容器或主机</td>
    </tr>
    <tr>
        <td>--isolation=”default ” </td>
        <td>容器使用的隔离机制 </td>
    </tr>
    <tr>
        <td>--log-driver="Json-file ” </td>
        <td>指定容器的日志驱动类型，可以为〕son-file、 syslog、 journald、 gelf 、 fluentd, awslogs、 splunk, etwlogs、 gcplogs 或 none  </td>
    </tr>
    <tr>
        <td>--log-opt=[ ]</td>
        <td>传递给日志驱动的选项 </td>
    </tr>
    <tr>
        <td>--net= "bridge"</td>
        <td>指定容器网络模式，包括 bridge、口one、其他容捺内网络、 host 的 网络或某个现有网络等</td>
    </tr>
    <tr>
        <td>－－net-alias=[ ] </td>
        <td>容器在网络中的别名 </td>
    </tr>
    <tr>
        <td>-P, --publish-all=true | false </td>
        <td>通过 NAT 机制将容器标记暴露的端口自动映射到本地主机的l临时端口  </td>
    </tr>
    <tr>
        <td>-p, - -publish=[ ] </td>
        <td> 指定如何映射到本地主机端口，例如 －p l l 234- l2234: 1234-2234  </td>
    </tr>
    <tr>
        <td>--pid=host</td>
        <td>容器的 PID 命名空间 </td>
    </tr>
    <tr>
        <td>--userns＝ "" </td>
        <td>启用 userns-remap 时配置用户命名空间的模式 </td>
    </tr>
    <tr>
        <td>--uts=host</td>
        <td>容器的 UTS 命名空间 </td>
    </tr>
    <tr>
        <td>--restart=”no" </td>
        <td>容器的重启策略，包括 no、 on- failure [:max-retry］ 、 always、 unless-stopped 等  </td>
    </tr>
    <tr>
        <td>- rm=true|false </td>
        <td>容器退出后是否自动删除，不能跟 －d 同时使用  </td>
    </tr>
    <tr>
        <td>-t, --tty=true|false</td>
        <td>是否分配一个伪终端，默认为 false</td>
    </tr>
    <tr>
        <td>--tmpfs=[ ]</td>
        <td>挂载临时文件系统到容器</td>
    </tr>
    <tr>
        <td>-v | --volume[=[[HOST DIR:] CONTAINER-DIR [:OPTIONS]]] t</td>
        <td>挂载主机上的文件卷到容器内</td>
    </tr>
    <tr>
        <td>--volume-driver=" ” </td>
        <td>挂载文件卷的驱动类型  </td>
    </tr>
    <tr>
        <td>- -volumes- from=[ ]</td>
        <td>从其他容器挂载卷  </td>
    </tr>
    <tr>
        <td>-w, --workdir="" </td>
        <td>容器内的默认工作目录 </td>
    </tr>
</table>

<p>​        </p>
<h4 id="create-命令与容器环境和配置相关的选项"><a href="#create-命令与容器环境和配置相关的选项" class="headerlink" title="create 命令与容器环境和配置相关的选项"></a>create 命令与容器环境和配置相关的选项</h4><table>
    <tr>
        <td>选项</td>
        <td>说明</td>
    </tr>
    <tr>
        <td>--add-host=[]</td>
        <td>在容器内添加一个主机名到 IP 地址的映射关系（通过／etc/hosts 文件） </td>
    </tr>
    <tr>
        <td>--device=[]</td>
        <td>映射物理机上的设备到容器内 </td>
    </tr>
    <tr>
        <td>--dns-search= []</td>
        <td>DNS 搜索域</td>
    </tr>
    <tr>
        <td>- -dns-opt=[ ]</td>
        <td>自定义的 DNS 选项</td>
    </tr>
    <tr>
        <td>--dns= []</td>
        <td>自定义的 DNS 服务器 </td>
    </tr>
    <tr>
        <td>- e,--env=[]</td>
        <td>指定容器内环境变量</td>
    </tr>
    <tr>
        <td>--env-file= []</td>
        <td>从文件中读取环境变量到容器内 </td>
    </tr>
    <tr>
        <td>- h, --hostname=""</td>
        <td>指定容器内的主机名</td>
    </tr>
    <tr>
        <td>--ip=""</td>
        <td>指定容器的IPv4 地址 </td>
    </tr>
    <tr>
        <td>- - ip6=””</td>
        <td>指定容器的IPv6 地址</td>
    </tr>
    <tr>
        <td>--link＝［<name or id>:alias]</name></td>
        <td>链接到其他容器 </td>
    </tr>
    <tr>
        <td>--link-local-ip= []:</td>
        <td>容器的本地链接地址列表 </td>
    </tr>
    <tr>
        <td>--mac-address=”“</td>
        <td>指定容器的 Mac 地址 </td>
    </tr>
    <tr>
        <td>--name=""</td>
        <td>指定容器的别名</td>
    </tr>
</table>

<h4 id="create-命令与容器资源限制和安全保护相关的选项"><a href="#create-命令与容器资源限制和安全保护相关的选项" class="headerlink" title="create 命令与容器资源限制和安全保护相关的选项"></a>create 命令与容器资源限制和安全保护相关的选项</h4><table>
    <tr align="center" valign="middle">
        <td>选项</td>
        <td>说明</td>
    </tr>
    <tr align="center" valign="middle">
        <td>--blkio-weight=l0-1000</td>
        <td>容器读写块设备的 1/0 性能权重，默认为 0</td>
    </tr>
    <tr align="center" valign="middle">
        <td>- - blkio-weight-device= [DEVICE NAME: WEIGHT] </td>
        <td>指定各个块设备的 IIO 性能权重</td>
    </tr>
    <tr align="center" valign="middle">
        <td>--cpu-shares=O </td>
        <td>允许容器使用 CPU 资源的相对权重，默认一个容器能用满一个核的 CPU </td>
    </tr>
    <tr align="center" valign="middle">
        <td>--cap add=[] </td>
        <td>增加容榕的 Linux 指定安全能力 </td>
    </tr>
    <tr align="center" valign="middle">
        <td>--cap-drop=[]</td>
        <td>移除容器的 Linux 指定安全能力 </td>
    </tr>
    <tr align="center" valign="middle">
        <td>--cgroup parent=” ”</td>
        <td>容器 cgroups 限制的创建路径 </td>
    </tr>
    <tr align="center" valign="middle">
        <td>--cidfile=” ”</td>
        <td>指定容器的进程 ID 号写到文件 </td>
    </tr>
    <tr align="center" valign="middle">
        <td>--cpu-period=O</td>
        <td> 限制j容器在 CFS 调度器下的 CPU 占用时间片 </td>
    </tr>
    <tr align="center" valign="middle">
        <td>--cpuset-cpus=” ” </td>
        <td>限制容器能使用哪些 CPU 核心 </td>
    </tr>
    <tr align="center" valign="middle">
        <td>--cpuset-mems=""</td>
        <td>NUMA 架构下使用哪些核心的内存 </td>
    </tr>
    <tr align="center" valign="middle">
        <td>--cpu-quota=O</td>
        <td>限制容器在 CFS调度下的 CPU占用时间片 </td>
    </tr>
    <tr align="center" valign="middle">
        <td>--cpuset-cpus=” ”</td>
        <td>限制容器能使用哪些 CPU 核心 </td>
    </tr>
    <tr align="center" valign="middle">
        <td>--cpuset-mems=""</td>
        <td>NUMA 架构下使用哪些核心的内存 </td>
    </tr>
    <tr align="center" valign="middle">
        <td>--cpu-quota=O</td>
        <td>限制容器在 CFSifli］度’lm下的 CPU 配额 </td>
    </tr>
    <tr align="center" valign="middle">
        <td>--device-read-bps=[]</td>
        <td>挂载设备的读吞吐率（以 bps 为单位）限制 </td>
    </tr>
    <tr align="center" valign="middle">
        <td>--device-write-bps=[]</td>
        <td>挂载设备的写吞吐率（以 bps 为单位）限制 </td>
    </tr>
    <tr align="center" valign="middle">
        <td>--device-read- iops=[]</td>
        <td>挂载设备的读速率（以每秒 i/o 次数为单位）限制 </td>
    </tr>
    <tr align="center" valign="middle">
        <td>--device-write-iops=[]</td>
        <td>挂载设备的写速率（以每秒 i/o 次数为单位）限制 </td>
    </tr>
    <tr align="center" valign="middle">
        <td>--health-cmd=””</td>
        <td>指定检查容器健康状态的命令 </td>
    </tr>
    <tr align="center" valign="middle">
        <td>--health-interval=OS</td>
        <td>执行健康检查的间隔时间，单位可以为 ms、 s、 m 或 h </td>
    </tr>
    <tr align="center" valign="middle">
        <td>--health-retries=int</td>
        <td>健康检查失败重试次数，超过则认为不健康 </td>
    </tr>
    <tr align="center" valign="middle">
        <td>--health-start period=Os</td>
        <td>容器启动后进行健康检查的等待时间 ， 单位可以为 ms、 s、 m 或 h </td>
    </tr>
    <tr align="center" valign="middle">
        <td>--health-t 工meout=Os</td>
        <td>健康检查的执行超时，单位可以为 ms、 s、 m 或 h</td>
    </tr>
    <tr align="center" valign="middle">
        <td>--no-healthcheck=true|false </td>
        <td>是否禁用健康检查 </td>
    </tr>
    <tr align="center" valign="middle">
        <td>--init</td>
        <td>在容器中执行一个 init 进程，来负责响应信号和处理僵尸状态子进程 </td>
    </tr>
    <tr align="center" valign="middle">
        <td>--kernel memory="" </td>
        <td>限制容器使用内核的内存大小， 单位可以是 b、 k、 m 或 g </td>
    </tr>
    <tr align="center" valign="middle">
        <td>-m, - -me mory =""</td>
        <td>限制容器内应用使用的内存，单位可以是 b、 k、 m 或 g</td>
    </tr>
    <tr align="center" valign="middle">
        <td>--memory-re s ervation=” ”</td>
        <td>当系统中内存过低时， 容器会被强制限制内存到给定值，默认情况下 等于内存限制值 </td>
    </tr>
    <tr align="center" valign="middle">
        <td>--memory swap=”LI MIT"</td>
        <td>限制容器使用内存和交换区的总大小 </td>
    </tr>
    <tr align="center" valign="middle">
        <td>--oom-kill-di sable=true|false</td>
        <td>内存耗尽时是否杀死容器 </td>
    </tr>
    <tr align="center" valign="middle">
        <td>--oom- score-adj=""</td>
        <td>调整容器的内存耗尽参数 </td>
    </tr>
    <tr align="center" valign="middle">
        <td>- -pids-limit=” ”</td>
        <td>限制容器的 pid 个数 </td>
    </tr>
    <tr align="center" valign="middle">
        <td>--privileged=true | false</td>
        <td>是否给容器高权限， 这意味着容器内应用将不受权限的限制， 一般不推荐</td>
    </tr>
    <tr align="center" valign="middle">
        <td>--read- only=true | false</td>
        <td>是否让容器内的文件系统只读 </td>
    </tr>
    <tr align="center" valign="middle">
        <td>- -security- opt = []</td>
        <td>指定一些安全参数， 包括权限、安全能力、 apparmor 等 </td>
    </tr>
    <tr align="center" valign="middle">
        <td>- -stop - signal=SIGTERM</td>
        <td>指定停止容器的系统信号 </td>
    </tr>
    <tr align="center" valign="middle">
        <td>- -shm- size =””</td>
        <td>/dev/shm 的大小</td>
    </tr>
    <tr align="center" valign="middle">
        <td> -- sig-proxy=true| false </td>
        <td>是否代理收到的信号给应用 ，默认为时ue， 不能代理 SIGCHLD、 SIGSTOP 和 SIGKILL 信号 </td>
    </tr>
    <tr align="center" valign="middle">
        <td>-- memory-swappiness=" O-100 。 ” </td>
        <td>调整容器的内存交换区参数</td>
    </tr>
    <tr align="center" valign="middle">
        <td>-u , --user＝""</td>
        <td> 指定在容器内执行命令的用户信息 </td>
    </tr>
    <tr align="center" valign="middle">
        <td>--userns= " "</td>
        <td>指定用户命名空间</td>
    </tr>
    <tr align="center" valign="middle">
        <td>--ulimit= []</td>
        <td>通过 ulimit 来限制最大文件数、最大进程数等</td>
    </tr>
</table>



<p>其他选项还包括：</p>
<p>-l, –label=[]:以键值对方式指定容器的标签信息；</p>
<p>–label-file=[]:从文件中读取标签信息</p>
<h4 id="2-启动容器"><a href="#2-启动容器" class="headerlink" title="2.启动容器"></a>2.启动容器</h4><p>使用docker [container] start 命令来启动一个已经创建的容器。例如，启动刚创建的ubuntu容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker start af</span><br></pre></td></tr></table></figure>

<p>此时，通过<span style="color:red">docker ps</span>命令，可以查看到一个运行中的容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br></pre></td></tr></table></figure>

<h4 id="3-新建并启动容器"><a href="#3-新建并启动容器" class="headerlink" title="3.新建并启动容器"></a>3.新建并启动容器</h4><p>除了创建容器后通过start命令来启动，也可以直接新建并启动容器</p>
<p>所需要的命令主要为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] run</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker [container] create</span><br><span class="line">docker [container] start</span><br></pre></td></tr></table></figure>

<p>例如，下面的命令输出一个“Hello World”,之后容器自动终止</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run ubuntu /bin/echo &apos;Hello world&apos;</span><br></pre></td></tr></table></figure>

<p>这跟在本地直接执行<span style="color:red">/bin/echo ‘hello world’</span>相比几乎感觉不出任何区别</p>
<p><strong>当利用docker [container] run 来创建并启动容器时，docker在后台运行的标准操作包括：</strong></p>
<ol>
<li><p>检查本地是否存在指定的镜像，不存在就从共有仓库下载</p>
</li>
<li><p>利用镜像创建一个容器，并启动该容器</p>
</li>
<li><p>分配一个文件系统给容器，并在只读的镜像层外面挂在一层可读写层</p>
</li>
<li><p>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中</p>
</li>
<li><p>从网桥的地址池配置一个IP地址给容器</p>
</li>
<li><p>执行用户指定的应用程序</p>
</li>
<li><p>执行完毕后容器被自动终止</p>
</li>
</ol>
<h5 id="下面的命令启动一个-bash-终端，允许用户进行交互："><a href="#下面的命令启动一个-bash-终端，允许用户进行交互：" class="headerlink" title="下面的命令启动一个 bash 终端，允许用户进行交互："></a>下面的命令启动一个 bash 终端，允许用户进行交互：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it ubuntu:18.04 /bin/bash</span><br></pre></td></tr></table></figure>

<p>其中，<span style="color:red;font-size=22px;"><b>-t</b></span>选项让Docker分配一个伪终端(pseudo-tty)并绑定到容器的标准输入上，<strong>-i</strong>则让容器的标准输入保持打开。更多的命令选项可以通过<strong>man docker-run</strong> 命令来查看。</p>
<p>在交互模式下，用户可以通过所创建的终端来输入命令，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@afBbae53bdd3:/# pwd </span><br><span class="line">/ </span><br><span class="line"></span><br><span class="line">root@afBbae53bdd3:/# ls </span><br><span class="line">bin boot dev etc home lib lib64 media mnt opt proc root ru卫 sbin srv sys tmp usr var </span><br><span class="line"></span><br><span class="line">root@afBbae53bdd3: /# ps </span><br><span class="line">PID TTY TIME CMD </span><br><span class="line">1 ? 00:00:00 bash </span><br><span class="line">11 ? 00:00:00 ps</span><br></pre></td></tr></table></figure>

<p>在容器内用 ps 命令查看进程，可以看到，只运行了bash应用，并没有运行其他无关的进程。用户可以按<strong>ctrl+d</strong>或输入<strong>exit</strong>命令来退出容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@afBbae53bdd3:/# exit </span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>对于所创建的bash容器，当用户使用exit命令推出bash进程之后，容器也会自动推出。这是因为对于容器来说，容器的使命完成，也就没有继续运行的必要了</p>
<p>某些时候，执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] wait CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>

<p>子命令来等待容器退出，并打印退出返回结果</p>
<p>某些时候，执行docker [container] run时候因为命令无法正常执行容器会出错直接退出，此时可以查看退出的错误代码。</p>
<p>默认情况下，常见错误代码包括:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">125:docker daemon执行出错，例如制定了不支持的docker命令参数</span><br><span class="line">126:所指定命令无法执行，例如权限出错</span><br><span class="line">127：容器内命令无法找到</span><br></pre></td></tr></table></figure>

<p>命令执行后出错，会默认返回命令的退出错误码</p>
<h4 id="守护态运行"><a href="#守护态运行" class="headerlink" title="守护态运行"></a>守护态运行</h4><p>需要让Docker在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加<code>-d</code>参数来实现</p>
<p>例如，下面的命令会在后台运行容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d ubuntu /bin/sh -c &quot;while true; do echo hello world; sleep 0.05; done&quot;</span><br><span class="line"></span><br><span class="line">ce554267d7a4c34eefc92c5517051dc37b918b588736d0823e4c846596b04d83</span><br></pre></td></tr></table></figure>

<p>容器启动后会返回一个唯一的id，也可以通过<strong>docker ps</strong> 或<strong>docker container ls</strong>命令来查看容器信息</p>
<h4 id="查看容器输出"><a href="#查看容器输出" class="headerlink" title="查看容器输出"></a>查看容器输出</h4><p>要获取容器的输出信息，可以通过docker [container] logs命令</p>
<p>该命令支持的选项包括：</p>
<ul>
<li>-details:打印详细信息</li>
<li>-f,-follow:持续保持输出</li>
<li>-since string:输出从某个时间开始的日志</li>
<li>-tail string:输出最近的若干日志</li>
<li>-t,-timestamps:显示时间戳信息</li>
<li>-until string:输出某个时间之前的日志</li>
</ul>
<p>例如，查看某容器的输出可以使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs ce554267d7a4</span><br></pre></td></tr></table></figure>

<h4 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h4><p>本节主要介绍 Docker 容器的 <strong>pause/unpause</strong>、 <strong>stop</strong> 和 <strong>prune</strong> 子命令。</p>
<h5 id="1-暂停容器"><a href="#1-暂停容器" class="headerlink" title="1.暂停容器"></a>1.暂停容器</h5><p>可以使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] pause CONTAINER [CONTAINER. . .]</span><br></pre></td></tr></table></figure>

<p>命令来暂停一个运行中的容器。</p>
<p>例如，启动一个容器，并将其暂停：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line">docker pause test</span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<p>处于paused状态中的容器，可以使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker unpause container</span><br></pre></td></tr></table></figure>

<p>来恢复到运行状态</p>
<h4 id="2-终止容器"><a href="#2-终止容器" class="headerlink" title="2.终止容器"></a>2.终止容器</h4><p>可以使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] stop</span><br></pre></td></tr></table></figure>

<p>来终止一个运行中的容器。该命令的格式为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] stop [-t|--time[=10] [container. . .]]</span><br></pre></td></tr></table></figure>

<p>该命令会首先向容器发送SIGTERM信号，等待一段超时时间后（默认为10秒 ），再发送SIGKILL信号来终止容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop ce5</span><br></pre></td></tr></table></figure>

<p>此时，执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container prune</span><br></pre></td></tr></table></figure>

<p><span style="color:red"><b>命令，会自动清除掉所有处于停止状态的容器。</b></span></p>
<p>此外，还可以通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] kill 直接发送SIGKILL信号来强行终止容器</span><br></pre></td></tr></table></figure>

<p>当docker容器中指定的应用终结时，容器也会自动终止。例如，对于上一章节中之启动了一个终端的容器，用户通过<strong>exit</strong>命令或<strong>ctrl+d</strong>来退出终端，所创建的容器立刻终止，处于stopped状态</p>
<p>可以用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -qa</span><br></pre></td></tr></table></figure>

<p>命令看到所有容器的ID</p>
<p>处于终止状态的容器，可以通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] start 容器ID</span><br></pre></td></tr></table></figure>

<p>命令来重新启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] restart 容器ID</span><br></pre></td></tr></table></figure>

<p>命令会将一个运行态的容器先终止，然后再重新启动：</p>
<h4 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h4><p>在使用-d参数时，容器启动后会进入后台，用户无法看到容器中的信息，也无法进行操作。</p>
<p>这个时候如果需要进入容器进行操作，推荐使用官方的<strong>attach</strong>或<strong>exec</strong>命令</p>
<h4 id="attach命令"><a href="#attach命令" class="headerlink" title="attach命令"></a>attach命令</h4><p>attach是docker自带的命令，命令格式为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] attach [--detach-keys[=[]]] [--no-stdin] [--sig-proxy[=true]] CONTAINER</span><br></pre></td></tr></table></figure>

<p>这个命令支持三个主要选项：</p>
<ul>
<li>–detach-keys[=[]] : 指定退出 attach 模式的快捷键序列，默认是CTRL-p CTRL-q </li>
<li>–no-stdin=true|false:是否关闭标准输入，默认是保持打开</li>
<li>–sig-proxy=true|false:是否代理收到的系统信号给应用进程，默认为true</li>
</ul>
<p>下面示例如何使用该命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd ubuntu</span><br><span class="line"></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line">docker attach 容器ID</span><br></pre></td></tr></table></figure>

<p>然而使用attach命令有时候并不方便。当多个窗口同时attach到同一个容器的时候，所有窗口都会同步显示；当某个窗口因命令阻塞时，其他窗口也无法执行操作了</p>
<h4 id="exec命令"><a href="#exec命令" class="headerlink" title="exec命令"></a>exec命令</h4><p>从docker的1.3.0版本起，docker提供了一个更加方便的工具exec命令，可以在运行中容器内直接执行任意命令。</p>
<p>该命令的基本格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] exec [-d|--detach] [--detach-keys[=[]]] [-i] --interactive] [--privileged] [-t|--tty] [-u|--user[=USER]] CONTAINER COMMAND [ARG. . .]</span><br></pre></td></tr></table></figure>

<p>比较重要的参数有:</p>
<ul>
<li><strong>-d,–detach</strong> ：在容器中后台执行命令</li>
<li><strong>–detach-keys=””</strong>：指定将容器切回后台的按键</li>
<li><strong>-e,–env=[]</strong>：指定环境变量列表</li>
<li><strong>-i,–interactive=true|false</strong>：打开标准输入接受用户输入命令，默认值为false</li>
<li><strong>–privileged=true|false</strong>：是否给执行命令以最高权限，默认值为false</li>
<li><strong>-t,–tty=true|false</strong>：分配伪终端，默认值为false</li>
<li><strong>-u,–user=””</strong>：执行命令的用户名或ID</li>
</ul>
<p>例如，进入到刚创建的容器中，并启动一个bash：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 容器ID /bin/bash</span><br></pre></td></tr></table></figure>

<p>可以看到会打开一个新的bash终端，在不影响容器内其他应用的前提下，用户可以与容器进行交互</p>
<p>通过指定 <strong>－it</strong> 参数来<strong>保持标准输入打开</strong>，并且<strong>分配一个伪终端</strong>。 通过 exec 命令对 容器执行操作是最为推荐的方式。</p>
<p>进一步地，可以在容器中查看容器中的用户和进程信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@243c32535da7:/# w </span><br><span class="line">11 :07:36 up 3:14, 0 users, load average : 0.00, O 02, 0.05 </span><br><span class="line">USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT </span><br><span class="line"></span><br><span class="line">root@243c32535da7:/# ps -ef</span><br></pre></td></tr></table></figure>

<h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><p>可以使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] rm</span><br></pre></td></tr></table></figure>

<p>命令来删除处于终止或推出状态的容器，命令格式为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] rm [-f|--force] [-l|--link] [-v|--volumes] CONTAINER [CONTAINER. . .]</span><br></pre></td></tr></table></figure>

<p>主要支持的选项包括:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-f,--force=false :是否强制终止并删除一个运行中的容器</span><br><span class="line">-l,--link=false :删除容器的连接，但保留容器</span><br><span class="line">-v,--volumes=false :删除容器挂在的数据卷</span><br></pre></td></tr></table></figure>

<p>例如，查看处于终止状态的容器，并删除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line">docker rm 容器id</span><br></pre></td></tr></table></figure>

<p>默认情况下，<strong>docker rm</strong> 命令只能删除已经处于终止或退出状态的容器，并不能删除还处于运行状态的容器</p>
<p>如果要直接删除一个运行中的容器，可以添加<strong>-f</strong>参数。docker会先发送SIGKILL信号给容器，终止其中的应用，之后强行删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d ubuntu:18.04 /bin/ sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</span><br><span class="line"></span><br><span class="line">docker rm -f 2ae</span><br></pre></td></tr></table></figure>

<h4 id="导入和导出容器"><a href="#导入和导出容器" class="headerlink" title="导入和导出容器"></a>导入和导出容器</h4><p>某些时候，需要将容器从一个系统迁移到另外一个系统，此时可以使用docker的导入和导出功能，这也是docker自身提供的一个重要特性</p>
<h5 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h5><p>导出容器是指，导出一个已经创建的容器到一个文件，不管此时这个容器是否处于运行状态。可以使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] export</span><br></pre></td></tr></table></figure>

<p>命令，该命令格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] export [-o|--output[=&quot;&quot;]] CONTAINER</span><br></pre></td></tr></table></figure>

<p>其中，可以通过<strong>-o选项</strong>来指定导出的tar文件名，也可以直接通过重定向来实现。</p>
<p>首先，查看所有的容器，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<p>分别导出两个容器到文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker export -o test_for_run.tar 容器ID</span><br><span class="line"></span><br><span class="line">ls</span><br><span class="line"></span><br><span class="line">docker export 容器ID &gt;test_for_stop.tar</span><br><span class="line"></span><br><span class="line">ls</span><br></pre></td></tr></table></figure>

<p>之后，可将导出的tar文件传输到其他机器上，然后再通过导入命令导入到系统中，实现容器的迁移</p>
<h5 id="导入容器"><a href="#导入容器" class="headerlink" title="导入容器"></a>导入容器</h5><p>导出的文件又可以使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] import</span><br></pre></td></tr></table></figure>

<p>命令导入变成镜像，该命令格式为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import [-c|--change[=[]]] [-m] --message[=MESSAGE] file|URL|-[REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure>

<p>用户可以通过-c.–change=[]选项在导入的同时执行对容器进行修改的dockerfile指令</p>
<p>下面将导出的 test for ru口 .tar 文件导人到系统中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import test_for_run.tar - test/ubuntu:v1.8</span><br></pre></td></tr></table></figure>

<p>之前的镜像章节（第 3 章）中，笔者曾介绍过使用 docker load 命令来导人一个镜像 文件，与 docker [container] import 命令十分类似。 实际上，既可以使用 docker load 命令来导入镜像存储文件到本地镜像库，也可以使 用 docker [container] import 命令来导入一个容器快照到本地镜像库。 这两者的区 别在于： 容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态）， 而镜像存储文件将保存完整记录，体积更大。 此外，从容器快照文件导人时可以重新指定标 签等元数据信息。</p>
<h4 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h4><p>本节主要介绍docker容器的inspect,top和stats子命令</p>
<ul>
<li><h5 id="查看容器详情"><a href="#查看容器详情" class="headerlink" title="查看容器详情"></a>查看容器详情</h5></li>
</ul>
<p>查看容器详情可以使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container inspect [options] container [container. . .] 子命令</span><br></pre></td></tr></table></figure>

<p>例如：查看某容器的具体信息，会以json格式返回包括容器ID，创建时间，路径，状态，镜像，配置等在内的各项信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container inspect test</span><br></pre></td></tr></table></figure>

<ul>
<li><h5 id="查看容器内进程"><a href="#查看容器内进程" class="headerlink" title="查看容器内进程"></a>查看容器内进程</h5></li>
</ul>
<p>查看容器内进程可以使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] top [options] container [container. . ]子命令</span><br></pre></td></tr></table></figure>

<p>这个子命令类似于linux系统中的top命令，会打印出容器内的进程信息，包括PID、用户、时间、命令等。例如，查看某容器内的进程信息，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top test</span><br></pre></td></tr></table></figure>

<ul>
<li><h5 id="查看统计信息"><a href="#查看统计信息" class="headerlink" title="查看统计信息"></a>查看统计信息</h5></li>
</ul>
<p>查看统计信息可以使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] stats [options] [container. . .] 子命令</span><br></pre></td></tr></table></figure>

<p>会显示CPU,内存，存储，网络等使用情况的统计信息</p>
<p>支持选项包括：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-a, -all:输出所有容器统计信息，默认仅在运行中</span><br><span class="line">-format string:格式化输出信息</span><br><span class="line">-no-stream：不持续输出，默认会自动更新持续实时结果</span><br><span class="line">-no-trunc:不截断输出信息</span><br></pre></td></tr></table></figure>

<p>例如，查看当前运行中容器的系统资源使用统计:</p>
<h4 id="其他容器命令"><a href="#其他容器命令" class="headerlink" title="其他容器命令"></a>其他容器命令</h4><p>本节主要介绍docker容器的cp,diff,port和update子命令</p>
<ul>
<li>复制文件</li>
</ul>
<p>container cp 命令支持在容器和主机之间复制文件。命令格式为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] cp [options] container:src_path dest_path | -</span><br></pre></td></tr></table></figure>

<p>支持的选项包括：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-a,-archive:打包模式，复制文件会带有原始的uid/gid信息</span><br><span class="line">-L，-follwo-link:跟随软连接，当原路径为软连接时，默认只复制链接信息，使用该选项会复制连接的目标内容</span><br></pre></td></tr></table></figure>

<p>例如，将本地的路径data复制到test容器的/tmp路径下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] cp data test:/tmp/</span><br></pre></td></tr></table></figure>

<h5 id="查看变更"><a href="#查看变更" class="headerlink" title="查看变更"></a>查看变更</h5><p>container diff 查看容器内文件系统的变更。命令格式为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] diff CONTAINER</span><br></pre></td></tr></table></figure>

<p>例如，查看test容器内的数据修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container diff test</span><br></pre></td></tr></table></figure>

<h5 id="查看端口映射"><a href="#查看端口映射" class="headerlink" title="查看端口映射"></a>查看端口映射</h5><p>container port 命令可以查看容器的端口映射情况。命令格式为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container port container [private_port[/proto]]</span><br></pre></td></tr></table></figure>

<p>例如，查看test容器的端口映射情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container port test</span><br></pre></td></tr></table></figure>

<p>更新配置</p>
<p>container update命令可以更新容器的一些运行时配置，主要是一些资源限制份额</p>
<p>命令格式为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [container] update [options] container [container. . .]</span><br></pre></td></tr></table></figure>

<p>支持的选项包括：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">－blkio-weight uintl6 ：更新块 IO 限制， 10～1000，默认值为 0，代表着无限制； </span><br><span class="line"></span><br><span class="line">－ cpu-period int ：限制 CPU 调度器 CFS (Completely Fair Scheduler）使用时间， 单位为微秒，最小 1000; </span><br><span class="line"></span><br><span class="line">－cpu-quota int ：限制 CPU 调度器 CFS 配额，单位为微秒，最小 1000;</span><br><span class="line"></span><br><span class="line">－cpu-rt -period int ：限制 CPU 调度器的实时周期，单位为微秒； </span><br><span class="line"></span><br><span class="line">－cpu-rt -runtime int ：限制 CPU 调度器的实时运行时，单位为微秒； </span><br><span class="line"></span><br><span class="line">－ c, -cpu-shares int ： 限制 CPU 使用份额； </span><br><span class="line"></span><br><span class="line">－cpus decimal ：限制 CPU 个数； </span><br><span class="line"></span><br><span class="line">－cpuset-cpus string：允许使用的 CPU 核，如 0-3, 0,1;</span><br><span class="line"></span><br><span class="line">－ cpuset -mems string：允许使用的内存块，如 0-3&apos; 0, 1; </span><br><span class="line"></span><br><span class="line">－kernel-memory bytes ：限制使用的内核内存； </span><br><span class="line"></span><br><span class="line">－m, -memory bytes ： 限制使用的内存； </span><br><span class="line"></span><br><span class="line">－memory-reservation bytes ：内存软限制； </span><br><span class="line"></span><br><span class="line">－memory-swap bytes ：内存加上缓存区的限制， －1 表示为对缓冲区无限制； </span><br><span class="line"></span><br><span class="line">－restart string： 容器退出后的重启策略。</span><br></pre></td></tr></table></figure>

<p>例如，限制总配额为1秒，容器test所占用时间为10%，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker update --cpu-quota 1000000 test</span><br><span class="line"></span><br><span class="line">docker update --cpu-period 1000000 test</span><br></pre></td></tr></table></figure>

<h4 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h4><p>​    容器是直接提供应用服务的组件，也是docker整个技术栈中最为核心的概念。围绕容器，docker提供了十分丰富的操作命令，允许用户高效地管理容器的整个生命周期。读者可以使用docker container help命令查看docker支持的容器操作子命令</p>
<p>​    通过本章内容的介绍和示例，相信读者已经掌握了对容器整个生命周期进行管理的各项操作命令</p>
<p>​    在生产环境中，为了提高容器的高可用性和安全性，一方面要合理使用资源限制参数来管理容器的资源消耗；另一方面要指定合适的容器重启策略。来自动重启推出的容器。此外，还可以使用<strong>HAProxy</strong>等辅助工具来处理负载均衡，自动切换故障的应用容器</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>ww</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://yoursite.com/2019/09/12/3容器操作命令/">http://yoursite.com/2019/09/12/3容器操作命令/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span></span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>good good stady</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/docker/"># docker</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2019/09/15/5数据管理/">docker数据管理</a>
            
            
            <a class="next" rel="next" href="/2019/09/09/sanic安装/">sanic安装</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© ww | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
